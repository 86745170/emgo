### Emgo follows Go specification with exception for memory allocation.

In Go, variable declared in function can be allocated on the stack or on the heap - escaping analisis is used for decision. In Emgo (like in C), all local variables are stack allocated. Dynamic allocation and garbage collection can occurs only when:

1. new or make builtin functions is used.
2. Non-epty strigs are concatanated. 
3. Builtin append function is called and there is not enough space in destiation.
4. An element to map is added or removed.

By default, dynamic allocation is disabled. Embeded applications often runs on MCUs that have only few kilobytes of SRAM and there can be no place for any dynamic memory allocation at all. If MCU has enough SRAM, dynamic allocation can be enabled by importing package that provides implementation for runtime.Alloc.

Example:

The following function is correct Go function:

func F() ([]byte, *int) {
	i := 4
	return []byte{1, 2, 3}, &i
}

but it isn't correct Emgo function - you need to rewrite it this way:

func F() ([]byte, *int) {
	i := new(int)
	*i = 4
	b := append([]byte{}, []byte{1, 2, 3}...)
	return b, i
}

If dynamic memory allocation is disabled you have to be careful when assign some variable to interface variable. Assigned variable should be a pointer or small variable that size is equal or less than size of uintptr.

### Generated C code.

Current Emgo implementation generates C code that relies on many GCC extensions.

### Standard library.

Emgo standard library doesn't follow Go standard library. There is always prefered to preserve Go package interface when porting it to Emgo.

#### Not yet implemented:

Interfaces.
Channels.
Variadic functions.
Returning array from function.
Type switch.
Package for dynamic memory.
String concatanation.
Append.