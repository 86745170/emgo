--------------------------------------------------------------------------------

#### Go, Emgo, C, assembler

Always use real Go if you can.

If you really can't use Go or you want to write protable code that can be used by both Go and Emgo (eg. portable library) write Emgo valid code. Correct Emgo code should always be valid Go code but oposite isn't true. Unfortunately, this means that there isn't possible to test Emgo code in Go enviroment. Testing embaded application isn't easy at all (TODO: we really need some packge that help).

Writing part of your package in C is probably really need only when you need to talk to the linker (sections, symbols, etc.) or use C intrinsic functions. Emgo standard library tries to provide all really useful intrinsics so use them instead. There is no embaded assembler in Emgo. If you really wan't to write assembly code that can be executed without any function call overhead, you have to write C (GCC) "always inline" function that contains inlined assembly.

If you want to write CPU specific function in CPU specific library you are free to write it in assembly. In not CPU specific library, you can optimize some function writing it in assembly but in this case, always provide portable Emgo function for other architectures.

#### Volatile fields and sync/barrier package

If your CPU guarantees ordered access to sime part of address spece, which is typical in case of memory mapped IO, you can use structs with fileds taged C:"volatile" to repesents IO registers in your program. This sometimes simplifies code and can slightly improve performance, but can cause bugs in more complicated cases.

So, in case of MMIO, use of structs with volatile fields may be desirable, but don't use volatile fields for any other thing. If you think that you need volatile variable for other thing than memory mapped IO, you are wrong. Volatile guarantees actual memory access for any access to volatile variable. Furthermore, order of accesses to volatile variables is preserved in generated binary code. But volatile doesn't guarante to preserve order between accesses to volatile and non-volatile variable and doesn't guarante any order of actual memory access during program execution (eg. CPU can execute instruction in different order, there may be buffers in hardware that reorder actual writes to different part of memory/MMIO, etc...). So, in case of ordinary memory, volatile is useless because you still have to use the appropriate function from sync/barrier package.