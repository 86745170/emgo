
Emgo specific coding guide, mandatory for standard library.
--------------------------------------------------------------------------------

#### Go, Emgo, C, assembler

If you want to write some application always prefer to write it in real Go.

If you really can't use Go or you want to write protable code that can be used by both Go and Emgo code (eg. portable library) write Emgo valid code. Correct Emgo code should always be valid Go code but oposite isn't true. This means that you can't test Emgo code in Go enviroment. Testing embaded application isn't easy at all (TODO: we really need some packge that help).

Writing part of your package in C is probably really need only when you need to talk to linker (sections, symbols, etc.) or use C intrinsic functions. Emgo standard library tries to provide all really useful intrinsics in platform independend way so use them instead. There will never be any embaded assembler in Emgo. If you really wan't to write assembly code that can be executed without any function call overhead, you have no alternative to write C (gcc) "always inline" function that contains inlined assembly code.

If you want to write CPU specific function in CPU specific library you are free to write it in assembly. You can optimize some function in not CPU specific library by writing it in assembly but in this case always provide portable Emgo function for other architectures.

#### Volatile structs

For memory mapped I/O use structs with fileds taged C:"volatile". Don't use "volatile structs" for any other thing. If you think that you need volatile variable for other thing than memory mapped I/O, you are wrong. Instead use ordinary variable and an appropriate function from sync package (TODO: info about channels when they will be available in Emgo).