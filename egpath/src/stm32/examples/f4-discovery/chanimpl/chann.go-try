package main

import (
	"runtime/noos"
	"sync/atomic"
	"sync/barrier"
	"unsafe"
)

type ChanN struct {
	dst   unsafe.Pointer
	event noos.Event
	state int32
}

const (
	sendLocked int32 = iota
	sendUnlocked
	// closed
)

func (c *ChanN) Close() {
	atomic.StoreInt32(&c.state, closed)
	c.event.Send()
}

func (c *ChanN) getDstAndUnlock() *unsafe.Pointer {
	// Save c.dst. It is only thing that is need for sender and receiver to
	// complete communication.
	dst := c.dst

	// Signal other senders and receivers that now c can be used by next pair.
	atomic.StorePointer(&c.dst, nil)
	barrier.Compiler()
	atomic.CompareAndSwapInt32(&c.state, sendLocked, sendUnlocked)
	c.event.Send()

	return (*unsafe.Pointer)(dst)
}

func (c *ChanN) Send() *unsafe.Pointer {
	for !atomic.CompareAndSwapInt32(&c.state, sendUnlocked, sendLocked) {
		panicIfClosed(atomic.LoadInt32(&c.state))
		// Other sender locked this channel.
		c.event.Wait()
	}

	// Wait for receiver.
	for atomic.LoadPointer(&c.dst) == nil {
		panicIfClosed(atomic.LoadInt32(&c.state))
		c.event.Wait()
	}

	return c.getDstAndUnlock()
}

func (c *ChanN) TrySend() *unsafe.Pointer {
	if !atomic.CompareAndSwapInt32(&c.state, sendUnlocked, sendLocked) {
		panicIfClosed(atomic.LoadInt32(&c.state))
		// Other sender locked this channel.
		return nil
	}

	if atomic.LoadPointer(&c.dst) == nil {
		// No any receiver is ready for communication.
		panicIfClosed(atomic.LoadInt32(&c.state))
		atomic.CompareAndSwapInt32(&c.state, sendLocked, sendUnlocked)
		c.event.Send()
		return nil
	}

	return c.getDstAndUnlock()
}

func (c *ChanN) Done(dst *unsafe.Pointer) {
	// Sync memory after data transfer.
	barrier.Memory()
	// Signal receiver that data were copied.
	atomic.StorePointer(dst, nil)
	c.event.Send()
}

func (c *ChanN) Recv(dst unsafe.Pointer) bool {
	for !atomic.CompareAndSwapPointer(&c.dst, nil, unsafe.Pointer(&dst)) {
		if atomic.LoadInt32(&c.state) == closed {
			return false
		}
		// Other receiver locked this channel.
		c.event.Wait()
	}

	// Wait for data from sender.
	for {
		if atomic.LoadPointer(&dst) == nil {
			return true
		}
		if atomic.LoadInt32(&c.state) == closed {
			return false
		}
		c.event.Wait()
	}
}
