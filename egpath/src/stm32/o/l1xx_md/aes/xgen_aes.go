package aes

// DO NOT EDIT THIS FILE. GENERATED BY xgen.

import (
	"bits"
	"mmio"
	"unsafe"

	"stm32/o/l1xx_md/mmap"
)

type AES_Periph struct {
	CR    RCR
	SR    RSR
	DINR  RDINR
	DOUTR RDOUTR
	KEYR0 RKEYR0
	KEYR1 RKEYR1
	KEYR2 RKEYR2
	KEYR3 RKEYR3
	IVR0  RIVR0
	IVR1  RIVR1
	IVR2  RIVR2
	IVR3  RIVR3
}

func (p *AES_Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

//emgo:const
var AES = (*AES_Periph)(unsafe.Pointer(uintptr(mmap.AES_BASE)))

type CR uint32

func (b CR) Field(mask CR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask CR) J(v int) CR {
	return CR(bits.MakeField32(v, uint32(mask)))
}

type RCR struct{ mmio.U32 }

func (r *RCR) Bits(mask CR) CR      { return CR(r.U32.Bits(uint32(mask))) }
func (r *RCR) StoreBits(mask, b CR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCR) SetBits(mask CR)      { r.U32.SetBits(uint32(mask)) }
func (r *RCR) ClearBits(mask CR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCR) Load() CR             { return CR(r.U32.Load()) }
func (r *RCR) Store(b CR)           { r.U32.Store(uint32(b)) }

func (r *RCR) AtomicStoreBits(mask, b CR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RCR) AtomicSetBits(mask CR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RCR) AtomicClearBits(mask CR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMCR struct{ mmio.UM32 }

func (rm RMCR) Load() CR   { return CR(rm.UM32.Load()) }
func (rm RMCR) Store(b CR) { rm.UM32.Store(uint32(b)) }

func (p *AES_Periph) EN() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(EN)}}
}

func (p *AES_Periph) DATATYPE() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(DATATYPE)}}
}

func (p *AES_Periph) MODE() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(MODE)}}
}

func (p *AES_Periph) CHMOD() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(CHMOD)}}
}

func (p *AES_Periph) CCFC() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(CCFC)}}
}

func (p *AES_Periph) ERRC() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(ERRC)}}
}

func (p *AES_Periph) CCIE() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(CCIE)}}
}

func (p *AES_Periph) ERRIE() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(ERRIE)}}
}

func (p *AES_Periph) DMAINEN() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(DMAINEN)}}
}

func (p *AES_Periph) DMAOUTEN() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(DMAOUTEN)}}
}

type SR uint32

func (b SR) Field(mask SR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask SR) J(v int) SR {
	return SR(bits.MakeField32(v, uint32(mask)))
}

type RSR struct{ mmio.U32 }

func (r *RSR) Bits(mask SR) SR      { return SR(r.U32.Bits(uint32(mask))) }
func (r *RSR) StoreBits(mask, b SR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RSR) SetBits(mask SR)      { r.U32.SetBits(uint32(mask)) }
func (r *RSR) ClearBits(mask SR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RSR) Load() SR             { return SR(r.U32.Load()) }
func (r *RSR) Store(b SR)           { r.U32.Store(uint32(b)) }

func (r *RSR) AtomicStoreBits(mask, b SR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RSR) AtomicSetBits(mask SR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RSR) AtomicClearBits(mask SR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMSR struct{ mmio.UM32 }

func (rm RMSR) Load() SR   { return SR(rm.UM32.Load()) }
func (rm RMSR) Store(b SR) { rm.UM32.Store(uint32(b)) }

func (p *AES_Periph) CCF() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(CCF)}}
}

func (p *AES_Periph) RDERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(RDERR)}}
}

func (p *AES_Periph) WRERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(WRERR)}}
}

type DINR uint32

func (b DINR) Field(mask DINR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask DINR) J(v int) DINR {
	return DINR(bits.MakeField32(v, uint32(mask)))
}

type RDINR struct{ mmio.U32 }

func (r *RDINR) Bits(mask DINR) DINR    { return DINR(r.U32.Bits(uint32(mask))) }
func (r *RDINR) StoreBits(mask, b DINR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RDINR) SetBits(mask DINR)      { r.U32.SetBits(uint32(mask)) }
func (r *RDINR) ClearBits(mask DINR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RDINR) Load() DINR             { return DINR(r.U32.Load()) }
func (r *RDINR) Store(b DINR)           { r.U32.Store(uint32(b)) }

func (r *RDINR) AtomicStoreBits(mask, b DINR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RDINR) AtomicSetBits(mask DINR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RDINR) AtomicClearBits(mask DINR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMDINR struct{ mmio.UM32 }

func (rm RMDINR) Load() DINR   { return DINR(rm.UM32.Load()) }
func (rm RMDINR) Store(b DINR) { rm.UM32.Store(uint32(b)) }

type DOUTR uint32

func (b DOUTR) Field(mask DOUTR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask DOUTR) J(v int) DOUTR {
	return DOUTR(bits.MakeField32(v, uint32(mask)))
}

type RDOUTR struct{ mmio.U32 }

func (r *RDOUTR) Bits(mask DOUTR) DOUTR   { return DOUTR(r.U32.Bits(uint32(mask))) }
func (r *RDOUTR) StoreBits(mask, b DOUTR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RDOUTR) SetBits(mask DOUTR)      { r.U32.SetBits(uint32(mask)) }
func (r *RDOUTR) ClearBits(mask DOUTR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RDOUTR) Load() DOUTR             { return DOUTR(r.U32.Load()) }
func (r *RDOUTR) Store(b DOUTR)           { r.U32.Store(uint32(b)) }

func (r *RDOUTR) AtomicStoreBits(mask, b DOUTR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RDOUTR) AtomicSetBits(mask DOUTR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RDOUTR) AtomicClearBits(mask DOUTR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMDOUTR struct{ mmio.UM32 }

func (rm RMDOUTR) Load() DOUTR   { return DOUTR(rm.UM32.Load()) }
func (rm RMDOUTR) Store(b DOUTR) { rm.UM32.Store(uint32(b)) }

type KEYR0 uint32

func (b KEYR0) Field(mask KEYR0) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask KEYR0) J(v int) KEYR0 {
	return KEYR0(bits.MakeField32(v, uint32(mask)))
}

type RKEYR0 struct{ mmio.U32 }

func (r *RKEYR0) Bits(mask KEYR0) KEYR0   { return KEYR0(r.U32.Bits(uint32(mask))) }
func (r *RKEYR0) StoreBits(mask, b KEYR0) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RKEYR0) SetBits(mask KEYR0)      { r.U32.SetBits(uint32(mask)) }
func (r *RKEYR0) ClearBits(mask KEYR0)    { r.U32.ClearBits(uint32(mask)) }
func (r *RKEYR0) Load() KEYR0             { return KEYR0(r.U32.Load()) }
func (r *RKEYR0) Store(b KEYR0)           { r.U32.Store(uint32(b)) }

func (r *RKEYR0) AtomicStoreBits(mask, b KEYR0) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RKEYR0) AtomicSetBits(mask KEYR0)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RKEYR0) AtomicClearBits(mask KEYR0)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMKEYR0 struct{ mmio.UM32 }

func (rm RMKEYR0) Load() KEYR0   { return KEYR0(rm.UM32.Load()) }
func (rm RMKEYR0) Store(b KEYR0) { rm.UM32.Store(uint32(b)) }

type KEYR1 uint32

func (b KEYR1) Field(mask KEYR1) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask KEYR1) J(v int) KEYR1 {
	return KEYR1(bits.MakeField32(v, uint32(mask)))
}

type RKEYR1 struct{ mmio.U32 }

func (r *RKEYR1) Bits(mask KEYR1) KEYR1   { return KEYR1(r.U32.Bits(uint32(mask))) }
func (r *RKEYR1) StoreBits(mask, b KEYR1) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RKEYR1) SetBits(mask KEYR1)      { r.U32.SetBits(uint32(mask)) }
func (r *RKEYR1) ClearBits(mask KEYR1)    { r.U32.ClearBits(uint32(mask)) }
func (r *RKEYR1) Load() KEYR1             { return KEYR1(r.U32.Load()) }
func (r *RKEYR1) Store(b KEYR1)           { r.U32.Store(uint32(b)) }

func (r *RKEYR1) AtomicStoreBits(mask, b KEYR1) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RKEYR1) AtomicSetBits(mask KEYR1)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RKEYR1) AtomicClearBits(mask KEYR1)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMKEYR1 struct{ mmio.UM32 }

func (rm RMKEYR1) Load() KEYR1   { return KEYR1(rm.UM32.Load()) }
func (rm RMKEYR1) Store(b KEYR1) { rm.UM32.Store(uint32(b)) }

type KEYR2 uint32

func (b KEYR2) Field(mask KEYR2) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask KEYR2) J(v int) KEYR2 {
	return KEYR2(bits.MakeField32(v, uint32(mask)))
}

type RKEYR2 struct{ mmio.U32 }

func (r *RKEYR2) Bits(mask KEYR2) KEYR2   { return KEYR2(r.U32.Bits(uint32(mask))) }
func (r *RKEYR2) StoreBits(mask, b KEYR2) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RKEYR2) SetBits(mask KEYR2)      { r.U32.SetBits(uint32(mask)) }
func (r *RKEYR2) ClearBits(mask KEYR2)    { r.U32.ClearBits(uint32(mask)) }
func (r *RKEYR2) Load() KEYR2             { return KEYR2(r.U32.Load()) }
func (r *RKEYR2) Store(b KEYR2)           { r.U32.Store(uint32(b)) }

func (r *RKEYR2) AtomicStoreBits(mask, b KEYR2) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RKEYR2) AtomicSetBits(mask KEYR2)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RKEYR2) AtomicClearBits(mask KEYR2)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMKEYR2 struct{ mmio.UM32 }

func (rm RMKEYR2) Load() KEYR2   { return KEYR2(rm.UM32.Load()) }
func (rm RMKEYR2) Store(b KEYR2) { rm.UM32.Store(uint32(b)) }

type KEYR3 uint32

func (b KEYR3) Field(mask KEYR3) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask KEYR3) J(v int) KEYR3 {
	return KEYR3(bits.MakeField32(v, uint32(mask)))
}

type RKEYR3 struct{ mmio.U32 }

func (r *RKEYR3) Bits(mask KEYR3) KEYR3   { return KEYR3(r.U32.Bits(uint32(mask))) }
func (r *RKEYR3) StoreBits(mask, b KEYR3) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RKEYR3) SetBits(mask KEYR3)      { r.U32.SetBits(uint32(mask)) }
func (r *RKEYR3) ClearBits(mask KEYR3)    { r.U32.ClearBits(uint32(mask)) }
func (r *RKEYR3) Load() KEYR3             { return KEYR3(r.U32.Load()) }
func (r *RKEYR3) Store(b KEYR3)           { r.U32.Store(uint32(b)) }

func (r *RKEYR3) AtomicStoreBits(mask, b KEYR3) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RKEYR3) AtomicSetBits(mask KEYR3)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RKEYR3) AtomicClearBits(mask KEYR3)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMKEYR3 struct{ mmio.UM32 }

func (rm RMKEYR3) Load() KEYR3   { return KEYR3(rm.UM32.Load()) }
func (rm RMKEYR3) Store(b KEYR3) { rm.UM32.Store(uint32(b)) }

type IVR0 uint32

func (b IVR0) Field(mask IVR0) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask IVR0) J(v int) IVR0 {
	return IVR0(bits.MakeField32(v, uint32(mask)))
}

type RIVR0 struct{ mmio.U32 }

func (r *RIVR0) Bits(mask IVR0) IVR0    { return IVR0(r.U32.Bits(uint32(mask))) }
func (r *RIVR0) StoreBits(mask, b IVR0) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RIVR0) SetBits(mask IVR0)      { r.U32.SetBits(uint32(mask)) }
func (r *RIVR0) ClearBits(mask IVR0)    { r.U32.ClearBits(uint32(mask)) }
func (r *RIVR0) Load() IVR0             { return IVR0(r.U32.Load()) }
func (r *RIVR0) Store(b IVR0)           { r.U32.Store(uint32(b)) }

func (r *RIVR0) AtomicStoreBits(mask, b IVR0) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RIVR0) AtomicSetBits(mask IVR0)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RIVR0) AtomicClearBits(mask IVR0)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMIVR0 struct{ mmio.UM32 }

func (rm RMIVR0) Load() IVR0   { return IVR0(rm.UM32.Load()) }
func (rm RMIVR0) Store(b IVR0) { rm.UM32.Store(uint32(b)) }

type IVR1 uint32

func (b IVR1) Field(mask IVR1) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask IVR1) J(v int) IVR1 {
	return IVR1(bits.MakeField32(v, uint32(mask)))
}

type RIVR1 struct{ mmio.U32 }

func (r *RIVR1) Bits(mask IVR1) IVR1    { return IVR1(r.U32.Bits(uint32(mask))) }
func (r *RIVR1) StoreBits(mask, b IVR1) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RIVR1) SetBits(mask IVR1)      { r.U32.SetBits(uint32(mask)) }
func (r *RIVR1) ClearBits(mask IVR1)    { r.U32.ClearBits(uint32(mask)) }
func (r *RIVR1) Load() IVR1             { return IVR1(r.U32.Load()) }
func (r *RIVR1) Store(b IVR1)           { r.U32.Store(uint32(b)) }

func (r *RIVR1) AtomicStoreBits(mask, b IVR1) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RIVR1) AtomicSetBits(mask IVR1)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RIVR1) AtomicClearBits(mask IVR1)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMIVR1 struct{ mmio.UM32 }

func (rm RMIVR1) Load() IVR1   { return IVR1(rm.UM32.Load()) }
func (rm RMIVR1) Store(b IVR1) { rm.UM32.Store(uint32(b)) }

type IVR2 uint32

func (b IVR2) Field(mask IVR2) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask IVR2) J(v int) IVR2 {
	return IVR2(bits.MakeField32(v, uint32(mask)))
}

type RIVR2 struct{ mmio.U32 }

func (r *RIVR2) Bits(mask IVR2) IVR2    { return IVR2(r.U32.Bits(uint32(mask))) }
func (r *RIVR2) StoreBits(mask, b IVR2) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RIVR2) SetBits(mask IVR2)      { r.U32.SetBits(uint32(mask)) }
func (r *RIVR2) ClearBits(mask IVR2)    { r.U32.ClearBits(uint32(mask)) }
func (r *RIVR2) Load() IVR2             { return IVR2(r.U32.Load()) }
func (r *RIVR2) Store(b IVR2)           { r.U32.Store(uint32(b)) }

func (r *RIVR2) AtomicStoreBits(mask, b IVR2) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RIVR2) AtomicSetBits(mask IVR2)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RIVR2) AtomicClearBits(mask IVR2)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMIVR2 struct{ mmio.UM32 }

func (rm RMIVR2) Load() IVR2   { return IVR2(rm.UM32.Load()) }
func (rm RMIVR2) Store(b IVR2) { rm.UM32.Store(uint32(b)) }

type IVR3 uint32

func (b IVR3) Field(mask IVR3) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask IVR3) J(v int) IVR3 {
	return IVR3(bits.MakeField32(v, uint32(mask)))
}

type RIVR3 struct{ mmio.U32 }

func (r *RIVR3) Bits(mask IVR3) IVR3    { return IVR3(r.U32.Bits(uint32(mask))) }
func (r *RIVR3) StoreBits(mask, b IVR3) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RIVR3) SetBits(mask IVR3)      { r.U32.SetBits(uint32(mask)) }
func (r *RIVR3) ClearBits(mask IVR3)    { r.U32.ClearBits(uint32(mask)) }
func (r *RIVR3) Load() IVR3             { return IVR3(r.U32.Load()) }
func (r *RIVR3) Store(b IVR3)           { r.U32.Store(uint32(b)) }

func (r *RIVR3) AtomicStoreBits(mask, b IVR3) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RIVR3) AtomicSetBits(mask IVR3)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RIVR3) AtomicClearBits(mask IVR3)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMIVR3 struct{ mmio.UM32 }

func (rm RMIVR3) Load() IVR3   { return IVR3(rm.UM32.Load()) }
func (rm RMIVR3) Store(b IVR3) { rm.UM32.Store(uint32(b)) }
