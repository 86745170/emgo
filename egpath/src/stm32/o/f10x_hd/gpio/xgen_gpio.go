package gpio

// DO NOT EDIT THIS FILE. GENERATED BY xgen.

import (
	"bits"
	"mmio"
	"unsafe"

	"stm32/o/f10x_hd/mmap"
)

type GPIO_Periph struct {
	CRL  RCRL
	CRH  RCRH
	IDR  RIDR
	ODR  RODR
	BSRR RBSRR
	BRR  RBRR
	LCKR RLCKR
}

func (p *GPIO_Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

//emgo:const
var GPIOA = (*GPIO_Periph)(unsafe.Pointer(uintptr(mmap.GPIOA_BASE)))

//emgo:const
var GPIOB = (*GPIO_Periph)(unsafe.Pointer(uintptr(mmap.GPIOB_BASE)))

//emgo:const
var GPIOC = (*GPIO_Periph)(unsafe.Pointer(uintptr(mmap.GPIOC_BASE)))

//emgo:const
var GPIOD = (*GPIO_Periph)(unsafe.Pointer(uintptr(mmap.GPIOD_BASE)))

//emgo:const
var GPIOE = (*GPIO_Periph)(unsafe.Pointer(uintptr(mmap.GPIOE_BASE)))

//emgo:const
var GPIOF = (*GPIO_Periph)(unsafe.Pointer(uintptr(mmap.GPIOF_BASE)))

//emgo:const
var GPIOG = (*GPIO_Periph)(unsafe.Pointer(uintptr(mmap.GPIOG_BASE)))

type CRL uint32

func (b CRL) Field(mask CRL) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask CRL) J(v int) CRL {
	return CRL(bits.MakeField32(v, uint32(mask)))
}

type RCRL struct{ mmio.U32 }

func (r *RCRL) Bits(mask CRL) CRL     { return CRL(r.U32.Bits(uint32(mask))) }
func (r *RCRL) StoreBits(mask, b CRL) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCRL) SetBits(mask CRL)      { r.U32.SetBits(uint32(mask)) }
func (r *RCRL) ClearBits(mask CRL)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCRL) Load() CRL             { return CRL(r.U32.Load()) }
func (r *RCRL) Store(b CRL)           { r.U32.Store(uint32(b)) }

func (r *RCRL) AtomicStoreBits(mask, b CRL) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RCRL) AtomicSetBits(mask CRL)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RCRL) AtomicClearBits(mask CRL)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMCRL struct{ mmio.UM32 }

func (rm RMCRL) Load() CRL   { return CRL(rm.UM32.Load()) }
func (rm RMCRL) Store(b CRL) { rm.UM32.Store(uint32(b)) }

func (p *GPIO_Periph) MODE() RMCRL {
	return RMCRL{mmio.UM32{&p.CRL.U32, uint32(MODE)}}
}

func (p *GPIO_Periph) CNF() RMCRL {
	return RMCRL{mmio.UM32{&p.CRL.U32, uint32(CNF)}}
}

type CRH uint32

func (b CRH) Field(mask CRH) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask CRH) J(v int) CRH {
	return CRH(bits.MakeField32(v, uint32(mask)))
}

type RCRH struct{ mmio.U32 }

func (r *RCRH) Bits(mask CRH) CRH     { return CRH(r.U32.Bits(uint32(mask))) }
func (r *RCRH) StoreBits(mask, b CRH) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCRH) SetBits(mask CRH)      { r.U32.SetBits(uint32(mask)) }
func (r *RCRH) ClearBits(mask CRH)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCRH) Load() CRH             { return CRH(r.U32.Load()) }
func (r *RCRH) Store(b CRH)           { r.U32.Store(uint32(b)) }

func (r *RCRH) AtomicStoreBits(mask, b CRH) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RCRH) AtomicSetBits(mask CRH)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RCRH) AtomicClearBits(mask CRH)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMCRH struct{ mmio.UM32 }

func (rm RMCRH) Load() CRH   { return CRH(rm.UM32.Load()) }
func (rm RMCRH) Store(b CRH) { rm.UM32.Store(uint32(b)) }

func (p *GPIO_Periph) MODE() RMCRH {
	return RMCRH{mmio.UM32{&p.CRH.U32, uint32(MODE)}}
}

func (p *GPIO_Periph) CNF() RMCRH {
	return RMCRH{mmio.UM32{&p.CRH.U32, uint32(CNF)}}
}

type IDR uint32

func (b IDR) Field(mask IDR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask IDR) J(v int) IDR {
	return IDR(bits.MakeField32(v, uint32(mask)))
}

type RIDR struct{ mmio.U32 }

func (r *RIDR) Bits(mask IDR) IDR     { return IDR(r.U32.Bits(uint32(mask))) }
func (r *RIDR) StoreBits(mask, b IDR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RIDR) SetBits(mask IDR)      { r.U32.SetBits(uint32(mask)) }
func (r *RIDR) ClearBits(mask IDR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RIDR) Load() IDR             { return IDR(r.U32.Load()) }
func (r *RIDR) Store(b IDR)           { r.U32.Store(uint32(b)) }

func (r *RIDR) AtomicStoreBits(mask, b IDR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RIDR) AtomicSetBits(mask IDR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RIDR) AtomicClearBits(mask IDR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMIDR struct{ mmio.UM32 }

func (rm RMIDR) Load() IDR   { return IDR(rm.UM32.Load()) }
func (rm RMIDR) Store(b IDR) { rm.UM32.Store(uint32(b)) }

func (p *GPIO_Periph) IDR0() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR0)}}
}

func (p *GPIO_Periph) IDR1() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR1)}}
}

func (p *GPIO_Periph) IDR2() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR2)}}
}

func (p *GPIO_Periph) IDR3() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR3)}}
}

func (p *GPIO_Periph) IDR4() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR4)}}
}

func (p *GPIO_Periph) IDR5() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR5)}}
}

func (p *GPIO_Periph) IDR6() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR6)}}
}

func (p *GPIO_Periph) IDR7() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR7)}}
}

func (p *GPIO_Periph) IDR8() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR8)}}
}

func (p *GPIO_Periph) IDR9() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR9)}}
}

func (p *GPIO_Periph) IDR10() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR10)}}
}

func (p *GPIO_Periph) IDR11() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR11)}}
}

func (p *GPIO_Periph) IDR12() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR12)}}
}

func (p *GPIO_Periph) IDR13() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR13)}}
}

func (p *GPIO_Periph) IDR14() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR14)}}
}

func (p *GPIO_Periph) IDR15() RMIDR {
	return RMIDR{mmio.UM32{&p.IDR.U32, uint32(IDR15)}}
}

type ODR uint32

func (b ODR) Field(mask ODR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask ODR) J(v int) ODR {
	return ODR(bits.MakeField32(v, uint32(mask)))
}

type RODR struct{ mmio.U32 }

func (r *RODR) Bits(mask ODR) ODR     { return ODR(r.U32.Bits(uint32(mask))) }
func (r *RODR) StoreBits(mask, b ODR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RODR) SetBits(mask ODR)      { r.U32.SetBits(uint32(mask)) }
func (r *RODR) ClearBits(mask ODR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RODR) Load() ODR             { return ODR(r.U32.Load()) }
func (r *RODR) Store(b ODR)           { r.U32.Store(uint32(b)) }

func (r *RODR) AtomicStoreBits(mask, b ODR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RODR) AtomicSetBits(mask ODR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RODR) AtomicClearBits(mask ODR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMODR struct{ mmio.UM32 }

func (rm RMODR) Load() ODR   { return ODR(rm.UM32.Load()) }
func (rm RMODR) Store(b ODR) { rm.UM32.Store(uint32(b)) }

func (p *GPIO_Periph) ODR0() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR0)}}
}

func (p *GPIO_Periph) ODR1() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR1)}}
}

func (p *GPIO_Periph) ODR2() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR2)}}
}

func (p *GPIO_Periph) ODR3() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR3)}}
}

func (p *GPIO_Periph) ODR4() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR4)}}
}

func (p *GPIO_Periph) ODR5() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR5)}}
}

func (p *GPIO_Periph) ODR6() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR6)}}
}

func (p *GPIO_Periph) ODR7() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR7)}}
}

func (p *GPIO_Periph) ODR8() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR8)}}
}

func (p *GPIO_Periph) ODR9() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR9)}}
}

func (p *GPIO_Periph) ODR10() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR10)}}
}

func (p *GPIO_Periph) ODR11() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR11)}}
}

func (p *GPIO_Periph) ODR12() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR12)}}
}

func (p *GPIO_Periph) ODR13() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR13)}}
}

func (p *GPIO_Periph) ODR14() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR14)}}
}

func (p *GPIO_Periph) ODR15() RMODR {
	return RMODR{mmio.UM32{&p.ODR.U32, uint32(ODR15)}}
}

type BSRR uint32

func (b BSRR) Field(mask BSRR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask BSRR) J(v int) BSRR {
	return BSRR(bits.MakeField32(v, uint32(mask)))
}

type RBSRR struct{ mmio.U32 }

func (r *RBSRR) Bits(mask BSRR) BSRR    { return BSRR(r.U32.Bits(uint32(mask))) }
func (r *RBSRR) StoreBits(mask, b BSRR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RBSRR) SetBits(mask BSRR)      { r.U32.SetBits(uint32(mask)) }
func (r *RBSRR) ClearBits(mask BSRR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RBSRR) Load() BSRR             { return BSRR(r.U32.Load()) }
func (r *RBSRR) Store(b BSRR)           { r.U32.Store(uint32(b)) }

func (r *RBSRR) AtomicStoreBits(mask, b BSRR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RBSRR) AtomicSetBits(mask BSRR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RBSRR) AtomicClearBits(mask BSRR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMBSRR struct{ mmio.UM32 }

func (rm RMBSRR) Load() BSRR   { return BSRR(rm.UM32.Load()) }
func (rm RMBSRR) Store(b BSRR) { rm.UM32.Store(uint32(b)) }

func (p *GPIO_Periph) BS0() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS0)}}
}

func (p *GPIO_Periph) BS1() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS1)}}
}

func (p *GPIO_Periph) BS2() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS2)}}
}

func (p *GPIO_Periph) BS3() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS3)}}
}

func (p *GPIO_Periph) BS4() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS4)}}
}

func (p *GPIO_Periph) BS5() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS5)}}
}

func (p *GPIO_Periph) BS6() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS6)}}
}

func (p *GPIO_Periph) BS7() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS7)}}
}

func (p *GPIO_Periph) BS8() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS8)}}
}

func (p *GPIO_Periph) BS9() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS9)}}
}

func (p *GPIO_Periph) BS10() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS10)}}
}

func (p *GPIO_Periph) BS11() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS11)}}
}

func (p *GPIO_Periph) BS12() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS12)}}
}

func (p *GPIO_Periph) BS13() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS13)}}
}

func (p *GPIO_Periph) BS14() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS14)}}
}

func (p *GPIO_Periph) BS15() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BS15)}}
}

func (p *GPIO_Periph) BR0() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR0)}}
}

func (p *GPIO_Periph) BR1() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR1)}}
}

func (p *GPIO_Periph) BR2() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR2)}}
}

func (p *GPIO_Periph) BR3() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR3)}}
}

func (p *GPIO_Periph) BR4() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR4)}}
}

func (p *GPIO_Periph) BR5() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR5)}}
}

func (p *GPIO_Periph) BR6() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR6)}}
}

func (p *GPIO_Periph) BR7() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR7)}}
}

func (p *GPIO_Periph) BR8() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR8)}}
}

func (p *GPIO_Periph) BR9() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR9)}}
}

func (p *GPIO_Periph) BR10() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR10)}}
}

func (p *GPIO_Periph) BR11() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR11)}}
}

func (p *GPIO_Periph) BR12() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR12)}}
}

func (p *GPIO_Periph) BR13() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR13)}}
}

func (p *GPIO_Periph) BR14() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR14)}}
}

func (p *GPIO_Periph) BR15() RMBSRR {
	return RMBSRR{mmio.UM32{&p.BSRR.U32, uint32(BR15)}}
}

type BRR uint32

func (b BRR) Field(mask BRR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask BRR) J(v int) BRR {
	return BRR(bits.MakeField32(v, uint32(mask)))
}

type RBRR struct{ mmio.U32 }

func (r *RBRR) Bits(mask BRR) BRR     { return BRR(r.U32.Bits(uint32(mask))) }
func (r *RBRR) StoreBits(mask, b BRR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RBRR) SetBits(mask BRR)      { r.U32.SetBits(uint32(mask)) }
func (r *RBRR) ClearBits(mask BRR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RBRR) Load() BRR             { return BRR(r.U32.Load()) }
func (r *RBRR) Store(b BRR)           { r.U32.Store(uint32(b)) }

func (r *RBRR) AtomicStoreBits(mask, b BRR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RBRR) AtomicSetBits(mask BRR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RBRR) AtomicClearBits(mask BRR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMBRR struct{ mmio.UM32 }

func (rm RMBRR) Load() BRR   { return BRR(rm.UM32.Load()) }
func (rm RMBRR) Store(b BRR) { rm.UM32.Store(uint32(b)) }

func (p *GPIO_Periph) BR0() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR0)}}
}

func (p *GPIO_Periph) BR1() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR1)}}
}

func (p *GPIO_Periph) BR2() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR2)}}
}

func (p *GPIO_Periph) BR3() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR3)}}
}

func (p *GPIO_Periph) BR4() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR4)}}
}

func (p *GPIO_Periph) BR5() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR5)}}
}

func (p *GPIO_Periph) BR6() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR6)}}
}

func (p *GPIO_Periph) BR7() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR7)}}
}

func (p *GPIO_Periph) BR8() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR8)}}
}

func (p *GPIO_Periph) BR9() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR9)}}
}

func (p *GPIO_Periph) BR10() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR10)}}
}

func (p *GPIO_Periph) BR11() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR11)}}
}

func (p *GPIO_Periph) BR12() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR12)}}
}

func (p *GPIO_Periph) BR13() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR13)}}
}

func (p *GPIO_Periph) BR14() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR14)}}
}

func (p *GPIO_Periph) BR15() RMBRR {
	return RMBRR{mmio.UM32{&p.BRR.U32, uint32(BR15)}}
}

type LCKR uint32

func (b LCKR) Field(mask LCKR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask LCKR) J(v int) LCKR {
	return LCKR(bits.MakeField32(v, uint32(mask)))
}

type RLCKR struct{ mmio.U32 }

func (r *RLCKR) Bits(mask LCKR) LCKR    { return LCKR(r.U32.Bits(uint32(mask))) }
func (r *RLCKR) StoreBits(mask, b LCKR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RLCKR) SetBits(mask LCKR)      { r.U32.SetBits(uint32(mask)) }
func (r *RLCKR) ClearBits(mask LCKR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RLCKR) Load() LCKR             { return LCKR(r.U32.Load()) }
func (r *RLCKR) Store(b LCKR)           { r.U32.Store(uint32(b)) }

func (r *RLCKR) AtomicStoreBits(mask, b LCKR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RLCKR) AtomicSetBits(mask LCKR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RLCKR) AtomicClearBits(mask LCKR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMLCKR struct{ mmio.UM32 }

func (rm RMLCKR) Load() LCKR   { return LCKR(rm.UM32.Load()) }
func (rm RMLCKR) Store(b LCKR) { rm.UM32.Store(uint32(b)) }

func (p *GPIO_Periph) LCK0() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK0)}}
}

func (p *GPIO_Periph) LCK1() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK1)}}
}

func (p *GPIO_Periph) LCK2() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK2)}}
}

func (p *GPIO_Periph) LCK3() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK3)}}
}

func (p *GPIO_Periph) LCK4() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK4)}}
}

func (p *GPIO_Periph) LCK5() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK5)}}
}

func (p *GPIO_Periph) LCK6() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK6)}}
}

func (p *GPIO_Periph) LCK7() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK7)}}
}

func (p *GPIO_Periph) LCK8() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK8)}}
}

func (p *GPIO_Periph) LCK9() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK9)}}
}

func (p *GPIO_Periph) LCK10() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK10)}}
}

func (p *GPIO_Periph) LCK11() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK11)}}
}

func (p *GPIO_Periph) LCK12() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK12)}}
}

func (p *GPIO_Periph) LCK13() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK13)}}
}

func (p *GPIO_Periph) LCK14() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK14)}}
}

func (p *GPIO_Periph) LCK15() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCK15)}}
}

func (p *GPIO_Periph) LCKK() RMLCKR {
	return RMLCKR{mmio.UM32{&p.LCKR.U32, uint32(LCKK)}}
}
