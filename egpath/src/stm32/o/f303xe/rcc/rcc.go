// Peripheral: RCC_Periph  Reset and Clock Control.
// Instances:
//  RCC  mmap.RCC_BASE
// Registers:
//  0x00 32  CR       Clock control register.
//  0x04 32  CFGR     Clock configuration register.
//  0x08 32  CIR      Clock interrupt register.
//  0x0C 32  APB2RSTR APB2 peripheral reset register.
//  0x10 32  APB1RSTR APB1 peripheral reset register.
//  0x14 32  AHBENR   AHB peripheral clock register.
//  0x18 32  APB2ENR  APB2 peripheral clock enable register.
//  0x1C 32  APB1ENR  APB1 peripheral clock enable register.
//  0x20 32  BDCR     Backup domain control register.
//  0x24 32  CSR      Clock control & status register.
//  0x28 32  AHBRSTR  AHB peripheral reset register.
//  0x2C 32  CFGR2    Clock configuration register 2.
//  0x30 32  CFGR3    Clock configuration register 3.
// Import:
//  stm32/o/f303xe/mmap
package rcc

// DO NOT EDIT THIS FILE. GENERATED BY stm32xgen.

const (
	HSION     CR_Bits = 0x01 << 0  //+
	HSIRDY    CR_Bits = 0x01 << 1  //+
	HSITRIM   CR_Bits = 0x1F << 3  //+
	HSITRIM_0 CR_Bits = 0x01 << 3  //  Bit 0.
	HSITRIM_1 CR_Bits = 0x02 << 3  //  Bit 1.
	HSITRIM_2 CR_Bits = 0x04 << 3  //  Bit 2.
	HSITRIM_3 CR_Bits = 0x08 << 3  //  Bit 3.
	HSITRIM_4 CR_Bits = 0x10 << 3  //  Bit 4.
	HSICAL    CR_Bits = 0xFF << 8  //+
	HSICAL_0  CR_Bits = 0x01 << 8  //  Bit 0.
	HSICAL_1  CR_Bits = 0x02 << 8  //  Bit 1.
	HSICAL_2  CR_Bits = 0x04 << 8  //  Bit 2.
	HSICAL_3  CR_Bits = 0x08 << 8  //  Bit 3.
	HSICAL_4  CR_Bits = 0x10 << 8  //  Bit 4.
	HSICAL_5  CR_Bits = 0x20 << 8  //  Bit 5.
	HSICAL_6  CR_Bits = 0x40 << 8  //  Bit 6.
	HSICAL_7  CR_Bits = 0x80 << 8  //  Bit 7.
	HSEON     CR_Bits = 0x01 << 16 //+
	HSERDY    CR_Bits = 0x01 << 17 //+
	HSEBYP    CR_Bits = 0x01 << 18 //+
	CSSON     CR_Bits = 0x01 << 19 //+
	PLLON     CR_Bits = 0x01 << 24 //+
	PLLRDY    CR_Bits = 0x01 << 25 //+
)

const (
	HSIONn   = 0
	HSIRDYn  = 1
	HSITRIMn = 3
	HSICALn  = 8
	HSEONn   = 16
	HSERDYn  = 17
	HSEBYPn  = 18
	CSSONn   = 19
	PLLONn   = 24
	PLLRDYn  = 25
)

const (
	SW                    CFGR_Bits = 0x03 << 0  //+ SW[1:0] bits (System clock Switch).
	SW_0                  CFGR_Bits = 0x01 << 0  //  Bit 0.
	SW_1                  CFGR_Bits = 0x02 << 0  //  Bit 1.
	SW_HSI                CFGR_Bits = 0x00 << 0  //  HSI selected as system clock.
	SW_HSE                CFGR_Bits = 0x01 << 0  //  HSE selected as system clock.
	SW_PLL                CFGR_Bits = 0x02 << 0  //  PLL selected as system clock.
	SWS                   CFGR_Bits = 0x03 << 2  //+ SWS[1:0] bits (System Clock Switch Status).
	SWS_0                 CFGR_Bits = 0x01 << 2  //  Bit 0.
	SWS_1                 CFGR_Bits = 0x02 << 2  //  Bit 1.
	SWS_HSI               CFGR_Bits = 0x00 << 2  //  HSI oscillator used as system clock.
	SWS_HSE               CFGR_Bits = 0x01 << 2  //  HSE oscillator used as system clock.
	SWS_PLL               CFGR_Bits = 0x02 << 2  //  PLL used as system clock.
	HPRE                  CFGR_Bits = 0x0F << 4  //+ HPRE[3:0] bits (AHB prescaler).
	HPRE_0                CFGR_Bits = 0x01 << 4  //  Bit 0.
	HPRE_1                CFGR_Bits = 0x02 << 4  //  Bit 1.
	HPRE_2                CFGR_Bits = 0x04 << 4  //  Bit 2.
	HPRE_3                CFGR_Bits = 0x08 << 4  //  Bit 3.
	HPRE_DIV1             CFGR_Bits = 0x00 << 4  //  SYSCLK not divided.
	HPRE_DIV2             CFGR_Bits = 0x08 << 4  //  SYSCLK divided by 2.
	HPRE_DIV4             CFGR_Bits = 0x09 << 4  //  SYSCLK divided by 4.
	HPRE_DIV8             CFGR_Bits = 0x0A << 4  //  SYSCLK divided by 8.
	HPRE_DIV16            CFGR_Bits = 0x0B << 4  //  SYSCLK divided by 16.
	HPRE_DIV64            CFGR_Bits = 0x0C << 4  //  SYSCLK divided by 64.
	HPRE_DIV128           CFGR_Bits = 0x0D << 4  //  SYSCLK divided by 128.
	HPRE_DIV256           CFGR_Bits = 0x0E << 4  //  SYSCLK divided by 256.
	HPRE_DIV512           CFGR_Bits = 0x0F << 4  //  SYSCLK divided by 512.
	PPRE1                 CFGR_Bits = 0x07 << 8  //+ PRE1[2:0] bits (APB1 prescaler).
	PPRE1_0               CFGR_Bits = 0x01 << 8  //  Bit 0.
	PPRE1_1               CFGR_Bits = 0x02 << 8  //  Bit 1.
	PPRE1_2               CFGR_Bits = 0x04 << 8  //  Bit 2.
	PPRE1_DIV1            CFGR_Bits = 0x00 << 8  //  HCLK not divided.
	PPRE1_DIV2            CFGR_Bits = 0x04 << 8  //  HCLK divided by 2.
	PPRE1_DIV4            CFGR_Bits = 0x05 << 8  //  HCLK divided by 4.
	PPRE1_DIV8            CFGR_Bits = 0x06 << 8  //  HCLK divided by 8.
	PPRE1_DIV16           CFGR_Bits = 0x07 << 8  //  HCLK divided by 16.
	PPRE2                 CFGR_Bits = 0x07 << 11 //+ PRE2[2:0] bits (APB2 prescaler).
	PPRE2_0               CFGR_Bits = 0x01 << 11 //  Bit 0.
	PPRE2_1               CFGR_Bits = 0x02 << 11 //  Bit 1.
	PPRE2_2               CFGR_Bits = 0x04 << 11 //  Bit 2.
	PPRE2_DIV1            CFGR_Bits = 0x00 << 11 //  HCLK not divided.
	PPRE2_DIV2            CFGR_Bits = 0x04 << 11 //  HCLK divided by 2.
	PPRE2_DIV4            CFGR_Bits = 0x05 << 11 //  HCLK divided by 4.
	PPRE2_DIV8            CFGR_Bits = 0x06 << 11 //  HCLK divided by 8.
	PPRE2_DIV16           CFGR_Bits = 0x07 << 11 //  HCLK divided by 16.
	PLLSRC                CFGR_Bits = 0x01 << 16 //+ PLL entry clock source.
	PLLXTPRE              CFGR_Bits = 0x01 << 17 //+ HSE divider for PLL entry.
	PLLMULL               CFGR_Bits = 0x0F << 18 //+ PLLMUL[3:0] bits (PLL multiplication factor).
	PLLMULL_0             CFGR_Bits = 0x01 << 18 //  Bit 0.
	PLLMULL_1             CFGR_Bits = 0x02 << 18 //  Bit 1.
	PLLMULL_2             CFGR_Bits = 0x04 << 18 //  Bit 2.
	PLLMULL_3             CFGR_Bits = 0x08 << 18 //  Bit 3.
	PLLSRC_HSI_Div2       CFGR_Bits = 0x00 << 18 //  HSI clock divided by 2 selected as PLL entry clock source.
	PLLSRC_HSI_PREDIV     CFGR_Bits = 0x01 << 15 //+ HSI PREDIV clock selected as PLL entry clock source.
	PLLSRC_PREDIV1        CFGR_Bits = 0x01 << 16 //  PREDIV1 clock selected as PLL entry clock source.
	PLLXTPRE_PREDIV1      CFGR_Bits = 0x00 << 15 //  PREDIV1 clock not divided for PLL entry.
	PLLXTPRE_PREDIV1_Div2 CFGR_Bits = 0x01 << 17 //  PREDIV1 clock divided by 2 for PLL entry.
	PLLMULL2              CFGR_Bits = 0x00 << 15 //  PLL input clock*2.
	PLLMULL3              CFGR_Bits = 0x01 << 18 //  PLL input clock*3.
	PLLMULL4              CFGR_Bits = 0x02 << 18 //  PLL input clock*4.
	PLLMULL5              CFGR_Bits = 0x03 << 18 //  PLL input clock*5.
	PLLMULL6              CFGR_Bits = 0x04 << 18 //  PLL input clock*6.
	PLLMULL7              CFGR_Bits = 0x05 << 18 //  PLL input clock*7.
	PLLMULL8              CFGR_Bits = 0x06 << 18 //  PLL input clock*8.
	PLLMULL9              CFGR_Bits = 0x07 << 18 //  PLL input clock*9.
	PLLMULL10             CFGR_Bits = 0x08 << 18 //  PLL input clock10.
	PLLMULL11             CFGR_Bits = 0x09 << 18 //  PLL input clock*11.
	PLLMULL12             CFGR_Bits = 0x0A << 18 //  PLL input clock*12.
	PLLMULL13             CFGR_Bits = 0x0B << 18 //  PLL input clock*13.
	PLLMULL14             CFGR_Bits = 0x0C << 18 //  PLL input clock*14.
	PLLMULL15             CFGR_Bits = 0x0D << 18 //  PLL input clock*15.
	PLLMULL16             CFGR_Bits = 0x0E << 18 //  PLL input clock*16.
	USBPRE                CFGR_Bits = 0x01 << 22 //+ USB prescaler.
	I2SSRC                CFGR_Bits = 0x01 << 23 //+ I2S external clock source selection.
	MCO                   CFGR_Bits = 0x07 << 24 //+ MCO[2:0] bits (Microcontroller Clock Output).
	MCO_0                 CFGR_Bits = 0x01 << 24 //  Bit 0.
	MCO_1                 CFGR_Bits = 0x02 << 24 //  Bit 1.
	MCO_2                 CFGR_Bits = 0x04 << 24 //  Bit 2.
	MCO_NOCLOCK           CFGR_Bits = 0x00 << 24 //  No clock.
	MCO_LSI               CFGR_Bits = 0x02 << 24 //  LSI clock selected as MCO source.
	MCO_LSE               CFGR_Bits = 0x03 << 24 //  LSE clock selected as MCO source.
	MCO_SYSCLK            CFGR_Bits = 0x04 << 24 //  System clock selected as MCO source.
	MCO_HSI               CFGR_Bits = 0x05 << 24 //  HSI clock selected as MCO source.
	MCO_HSE               CFGR_Bits = 0x06 << 24 //  HSE clock selected as MCO source.
	MCO_PLL               CFGR_Bits = 0x07 << 24 //  PLL clock divided by 2 selected as MCO source.
	MCOF                  CFGR_Bits = 0x01 << 28 //+ Microcontroller Clock Output Flag.
	MCO_PRE               CFGR_Bits = 0x07 << 28 //  MCO prescaler.
	MCO_PRE_1             CFGR_Bits = 0x00 << 28 //  MCO is divided by 1.
	MCO_PRE_2             CFGR_Bits = 0x01 << 28 //  MCO is divided by 2.
	MCO_PRE_4             CFGR_Bits = 0x01 << 29 //+ MCO is divided by 4.
	MCO_PRE_8             CFGR_Bits = 0x03 << 28 //  MCO is divided by 8.
	MCO_PRE_16            CFGR_Bits = 0x01 << 30 //+ MCO is divided by 16.
	MCO_PRE_32            CFGR_Bits = 0x05 << 28 //  MCO is divided by 32.
	MCO_PRE_64            CFGR_Bits = 0x03 << 29 //  MCO is divided by 64.
	MCO_PRE_128           CFGR_Bits = 0x07 << 28 //  MCO is divided by 128.
	PLLNODIV              CFGR_Bits = 0x01 << 31 //+ PLL is not divided to MCO.
)

const (
	SWn                = 0
	SWSn               = 2
	HPREn              = 4
	PPRE1n             = 8
	PPRE2n             = 11
	PLLSRCn            = 16
	PLLXTPREn          = 17
	PLLMULLn           = 18
	PLLSRC_HSI_PREDIVn = 15
	USBPREn            = 22
	I2SSRCn            = 23
	MCOn               = 24
	MCOFn              = 28
	MCO_PRE_4n         = 29
	MCO_PRE_16n        = 30
	PLLNODIVn          = 31
)

const (
	LSIRDYF  CIR_Bits = 0x01 << 0  //+ LSI Ready Interrupt flag.
	LSERDYF  CIR_Bits = 0x01 << 1  //+ LSE Ready Interrupt flag.
	HSIRDYF  CIR_Bits = 0x01 << 2  //+ HSI Ready Interrupt flag.
	HSERDYF  CIR_Bits = 0x01 << 3  //+ HSE Ready Interrupt flag.
	PLLRDYF  CIR_Bits = 0x01 << 4  //+ PLL Ready Interrupt flag.
	CSSF     CIR_Bits = 0x01 << 7  //+ Clock Security System Interrupt flag.
	LSIRDYIE CIR_Bits = 0x01 << 8  //+ LSI Ready Interrupt Enable.
	LSERDYIE CIR_Bits = 0x01 << 9  //+ LSE Ready Interrupt Enable.
	HSIRDYIE CIR_Bits = 0x01 << 10 //+ HSI Ready Interrupt Enable.
	HSERDYIE CIR_Bits = 0x01 << 11 //+ HSE Ready Interrupt Enable.
	PLLRDYIE CIR_Bits = 0x01 << 12 //+ PLL Ready Interrupt Enable.
	LSIRDYC  CIR_Bits = 0x01 << 16 //+ LSI Ready Interrupt Clear.
	LSERDYC  CIR_Bits = 0x01 << 17 //+ LSE Ready Interrupt Clear.
	HSIRDYC  CIR_Bits = 0x01 << 18 //+ HSI Ready Interrupt Clear.
	HSERDYC  CIR_Bits = 0x01 << 19 //+ HSE Ready Interrupt Clear.
	PLLRDYC  CIR_Bits = 0x01 << 20 //+ PLL Ready Interrupt Clear.
	CSSC     CIR_Bits = 0x01 << 23 //+ Clock Security System Interrupt Clear.
)

const (
	LSIRDYFn  = 0
	LSERDYFn  = 1
	HSIRDYFn  = 2
	HSERDYFn  = 3
	PLLRDYFn  = 4
	CSSFn     = 7
	LSIRDYIEn = 8
	LSERDYIEn = 9
	HSIRDYIEn = 10
	HSERDYIEn = 11
	PLLRDYIEn = 12
	LSIRDYCn  = 16
	LSERDYCn  = 17
	HSIRDYCn  = 18
	HSERDYCn  = 19
	PLLRDYCn  = 20
	CSSCn     = 23
)

const (
	SYSCFGRST APB2RSTR_Bits = 0x01 << 0  //+ SYSCFG reset.
	TIM1RST   APB2RSTR_Bits = 0x01 << 9  //+ TIM1 reset.
	SPI1RST   APB2RSTR_Bits = 0x01 << 12 //+ SPI1 reset.
	TIM8RST   APB2RSTR_Bits = 0x01 << 13 //+ TIM8 reset.
	USART1RST APB2RSTR_Bits = 0x01 << 14 //+ USART1 reset.
	SPI4RST   APB2RSTR_Bits = 0x01 << 15 //+ SPI4 reset.
	TIM15RST  APB2RSTR_Bits = 0x01 << 16 //+ TIM15 reset.
	TIM16RST  APB2RSTR_Bits = 0x01 << 17 //+ TIM16 reset.
	TIM17RST  APB2RSTR_Bits = 0x01 << 18 //+ TIM17 reset.
	TIM20RST  APB2RSTR_Bits = 0x01 << 20 //+ TIM20 reset.
	HRTIM1RST APB2RSTR_Bits = 0x01 << 29 //+ HRTIM1 reset.
)

const (
	SYSCFGRSTn = 0
	TIM1RSTn   = 9
	SPI1RSTn   = 12
	TIM8RSTn   = 13
	USART1RSTn = 14
	SPI4RSTn   = 15
	TIM15RSTn  = 16
	TIM16RSTn  = 17
	TIM17RSTn  = 18
	TIM20RSTn  = 20
	HRTIM1RSTn = 29
)

const (
	TIM2RST   APB1RSTR_Bits = 0x01 << 0  //+ Timer 2 reset.
	TIM3RST   APB1RSTR_Bits = 0x01 << 1  //+ Timer 3 reset.
	TIM4RST   APB1RSTR_Bits = 0x01 << 2  //+ Timer 4 reset.
	TIM6RST   APB1RSTR_Bits = 0x01 << 4  //+ Timer 6 reset.
	TIM7RST   APB1RSTR_Bits = 0x01 << 5  //+ Timer 7 reset.
	WWDGRST   APB1RSTR_Bits = 0x01 << 11 //+ Window Watchdog reset.
	SPI2RST   APB1RSTR_Bits = 0x01 << 14 //+ SPI2 reset.
	SPI3RST   APB1RSTR_Bits = 0x01 << 15 //+ SPI3 reset.
	USART2RST APB1RSTR_Bits = 0x01 << 17 //+ USART 2 reset.
	USART3RST APB1RSTR_Bits = 0x01 << 18 //+ USART 3 reset.
	UART4RST  APB1RSTR_Bits = 0x01 << 19 //+ UART 4 reset.
	UART5RST  APB1RSTR_Bits = 0x01 << 20 //+ UART 5 reset.
	I2C1RST   APB1RSTR_Bits = 0x01 << 21 //+ I2C 1 reset.
	I2C2RST   APB1RSTR_Bits = 0x01 << 22 //+ I2C 2 reset.
	USBRST    APB1RSTR_Bits = 0x01 << 23 //+ USB reset.
	CAN1RST   APB1RSTR_Bits = 0x01 << 25 //+ CAN reset.
	PWRRST    APB1RSTR_Bits = 0x01 << 28 //+ PWR reset.
	DAC1RST   APB1RSTR_Bits = 0x01 << 29 //+ DAC 1 reset.
	I2C3RST   APB1RSTR_Bits = 0x01 << 30 //+ I2C 3 reset.
	DAC2RST   APB1RSTR_Bits = 0x01 << 26 //+ DAC 2 reset.
)

const (
	TIM2RSTn   = 0
	TIM3RSTn   = 1
	TIM4RSTn   = 2
	TIM6RSTn   = 4
	TIM7RSTn   = 5
	WWDGRSTn   = 11
	SPI2RSTn   = 14
	SPI3RSTn   = 15
	USART2RSTn = 17
	USART3RSTn = 18
	UART4RSTn  = 19
	UART5RSTn  = 20
	I2C1RSTn   = 21
	I2C2RSTn   = 22
	USBRSTn    = 23
	CAN1RSTn   = 25
	PWRRSTn    = 28
	DAC1RSTn   = 29
	I2C3RSTn   = 30
	DAC2RSTn   = 26
)

const (
	DMA1EN  AHBENR_Bits = 0x01 << 0  //+ DMA1 clock enable.
	DMA2EN  AHBENR_Bits = 0x01 << 1  //+ DMA2 clock enable.
	SRAMEN  AHBENR_Bits = 0x01 << 2  //+ SRAM interface clock enable.
	FLITFEN AHBENR_Bits = 0x01 << 4  //+ FLITF clock enable.
	FMCEN   AHBENR_Bits = 0x01 << 5  //+ FMC clock enable.
	CRCEN   AHBENR_Bits = 0x01 << 6  //+ CRC clock enable.
	GPIOHEN AHBENR_Bits = 0x01 << 16 //+ GPIOH clock enable.
	GPIOAEN AHBENR_Bits = 0x01 << 17 //+ GPIOA clock enable.
	GPIOBEN AHBENR_Bits = 0x01 << 18 //+ GPIOB clock enable.
	GPIOCEN AHBENR_Bits = 0x01 << 19 //+ GPIOC clock enable.
	GPIODEN AHBENR_Bits = 0x01 << 20 //+ GPIOD clock enable.
	GPIOEEN AHBENR_Bits = 0x01 << 21 //+ GPIOE clock enable.
	GPIOFEN AHBENR_Bits = 0x01 << 22 //+ GPIOF clock enable.
	GPIOGEN AHBENR_Bits = 0x01 << 23 //+ GPIOG clock enable.
	TSEN    AHBENR_Bits = 0x01 << 24 //+ TS clock enable.
	ADC12EN AHBENR_Bits = 0x01 << 28 //+ ADC1/ ADC2 clock enable.
	ADC34EN AHBENR_Bits = 0x01 << 29 //+ ADC1/ ADC2 clock enable.
)

const (
	DMA1ENn  = 0
	DMA2ENn  = 1
	SRAMENn  = 2
	FLITFENn = 4
	FMCENn   = 5
	CRCENn   = 6
	GPIOHENn = 16
	GPIOAENn = 17
	GPIOBENn = 18
	GPIOCENn = 19
	GPIODENn = 20
	GPIOEENn = 21
	GPIOFENn = 22
	GPIOGENn = 23
	TSENn    = 24
	ADC12ENn = 28
	ADC34ENn = 29
)

const (
	SYSCFGEN APB2ENR_Bits = 0x01 << 0  //+ SYSCFG clock enable.
	TIM1EN   APB2ENR_Bits = 0x01 << 11 //+ TIM1 clock enable.
	SPI1EN   APB2ENR_Bits = 0x01 << 12 //+ SPI1 clock enable.
	TIM8EN   APB2ENR_Bits = 0x01 << 13 //+ TIM8 clock enable.
	USART1EN APB2ENR_Bits = 0x01 << 14 //+ USART1 clock enable.
	SPI4EN   APB2ENR_Bits = 0x01 << 15 //+ SPI4 clock enable.
	TIM15EN  APB2ENR_Bits = 0x01 << 16 //+ TIM15 clock enable.
	TIM16EN  APB2ENR_Bits = 0x01 << 17 //+ TIM16 clock enable.
	TIM17EN  APB2ENR_Bits = 0x01 << 18 //+ TIM17 clock enable.
	TIM20EN  APB2ENR_Bits = 0x01 << 20 //+ TIM20 clock enable.
	HRTIM1   APB2ENR_Bits = 0x01 << 29 //+ HRTIM1 clock enable.
)

const (
	SYSCFGENn = 0
	TIM1ENn   = 11
	SPI1ENn   = 12
	TIM8ENn   = 13
	USART1ENn = 14
	SPI4ENn   = 15
	TIM15ENn  = 16
	TIM16ENn  = 17
	TIM17ENn  = 18
	TIM20ENn  = 20
	HRTIM1n   = 29
)

const (
	TIM2EN   APB1ENR_Bits = 0x01 << 0  //+ Timer 2 clock enable.
	TIM3EN   APB1ENR_Bits = 0x01 << 1  //+ Timer 3 clock enable.
	TIM4EN   APB1ENR_Bits = 0x01 << 2  //+ Timer 4 clock enable.
	TIM6EN   APB1ENR_Bits = 0x01 << 4  //+ Timer 6 clock enable.
	TIM7EN   APB1ENR_Bits = 0x01 << 5  //+ Timer 7 clock enable.
	WWDGEN   APB1ENR_Bits = 0x01 << 11 //+ Window Watchdog clock enable.
	SPI2EN   APB1ENR_Bits = 0x01 << 14 //+ SPI2 clock enable.
	SPI3EN   APB1ENR_Bits = 0x01 << 15 //+ SPI3 clock enable.
	USART2EN APB1ENR_Bits = 0x01 << 17 //+ USART 2 clock enable.
	USART3EN APB1ENR_Bits = 0x01 << 18 //+ USART 3 clock enable.
	UART4EN  APB1ENR_Bits = 0x01 << 19 //+ UART 4 clock enable.
	UART5EN  APB1ENR_Bits = 0x01 << 20 //+ UART 5 clock enable.
	I2C1EN   APB1ENR_Bits = 0x01 << 21 //+ I2C 1 clock enable.
	I2C2EN   APB1ENR_Bits = 0x01 << 22 //+ I2C 2 clock enable.
	USBEN    APB1ENR_Bits = 0x01 << 23 //+ USB clock enable.
	CAN1EN   APB1ENR_Bits = 0x01 << 25 //+ CAN clock enable.
	DAC2EN   APB1ENR_Bits = 0x01 << 26 //+ DAC 2 clock enable.
	PWREN    APB1ENR_Bits = 0x01 << 28 //+ PWR clock enable.
	DAC1EN   APB1ENR_Bits = 0x01 << 29 //+ DAC clock enable.
	I2C3EN   APB1ENR_Bits = 0x01 << 30 //+ I2C 3 clock enable.
)

const (
	TIM2ENn   = 0
	TIM3ENn   = 1
	TIM4ENn   = 2
	TIM6ENn   = 4
	TIM7ENn   = 5
	WWDGENn   = 11
	SPI2ENn   = 14
	SPI3ENn   = 15
	USART2ENn = 17
	USART3ENn = 18
	UART4ENn  = 19
	UART5ENn  = 20
	I2C1ENn   = 21
	I2C2ENn   = 22
	USBENn    = 23
	CAN1ENn   = 25
	DAC2ENn   = 26
	PWRENn    = 28
	DAC1ENn   = 29
	I2C3ENn   = 30
)

const (
	LSEON          BDCR_Bits = 0x01 << 0  //+ External Low Speed oscillator enable.
	LSERDY         BDCR_Bits = 0x01 << 1  //+ External Low Speed oscillator Ready.
	LSEBYP         BDCR_Bits = 0x01 << 2  //+ External Low Speed oscillator Bypass.
	LSEDRV         BDCR_Bits = 0x03 << 3  //+ LSEDRV[1:0] bits (LSE Osc. drive capability).
	LSEDRV_0       BDCR_Bits = 0x01 << 3  //  Bit 0.
	LSEDRV_1       BDCR_Bits = 0x02 << 3  //  Bit 1.
	RTCSEL         BDCR_Bits = 0x03 << 8  //+ RTCSEL[1:0] bits (RTC clock source selection).
	RTCSEL_0       BDCR_Bits = 0x01 << 8  //  Bit 0.
	RTCSEL_1       BDCR_Bits = 0x02 << 8  //  Bit 1.
	RTCSEL_NOCLOCK BDCR_Bits = 0x00 << 8  //  No clock.
	RTCSEL_LSE     BDCR_Bits = 0x01 << 8  //  LSE oscillator clock used as RTC clock.
	RTCSEL_LSI     BDCR_Bits = 0x02 << 8  //  LSI oscillator clock used as RTC clock.
	RTCSEL_HSE     BDCR_Bits = 0x03 << 8  //  HSE oscillator clock divided by 32 used as RTC clock.
	RTCEN          BDCR_Bits = 0x01 << 15 //+ RTC clock enable.
	BDRST          BDCR_Bits = 0x01 << 16 //+ Backup domain software reset.
)

const (
	LSEONn  = 0
	LSERDYn = 1
	LSEBYPn = 2
	LSEDRVn = 3
	RTCSELn = 8
	RTCENn  = 15
	BDRSTn  = 16
)

const (
	LSION    CSR_Bits = 0x01 << 0  //+ Internal Low Speed oscillator enable.
	LSIRDY   CSR_Bits = 0x01 << 1  //+ Internal Low Speed oscillator Ready.
	RMVF     CSR_Bits = 0x01 << 24 //+ Remove reset flag.
	OBLRSTF  CSR_Bits = 0x01 << 25 //+ OBL reset flag.
	PINRSTF  CSR_Bits = 0x01 << 26 //+ PIN reset flag.
	PORRSTF  CSR_Bits = 0x01 << 27 //+ POR/PDR reset flag.
	SFTRSTF  CSR_Bits = 0x01 << 28 //+ Software Reset flag.
	IWDGRSTF CSR_Bits = 0x01 << 29 //+ Independent Watchdog reset flag.
	WWDGRSTF CSR_Bits = 0x01 << 30 //+ Window watchdog reset flag.
	LPWRRSTF CSR_Bits = 0x01 << 31 //+ Low-Power reset flag.
)

const (
	LSIONn    = 0
	LSIRDYn   = 1
	RMVFn     = 24
	OBLRSTFn  = 25
	PINRSTFn  = 26
	PORRSTFn  = 27
	SFTRSTFn  = 28
	IWDGRSTFn = 29
	WWDGRSTFn = 30
	LPWRRSTFn = 31
)

const (
	FMCRST   AHBRSTR_Bits = 0x01 << 5  //+ FMC reset.
	GPIOHRST AHBRSTR_Bits = 0x01 << 16 //+ GPIOH reset.
	GPIOARST AHBRSTR_Bits = 0x01 << 17 //+ GPIOA reset.
	GPIOBRST AHBRSTR_Bits = 0x01 << 18 //+ GPIOB reset.
	GPIOCRST AHBRSTR_Bits = 0x01 << 19 //+ GPIOC reset.
	GPIODRST AHBRSTR_Bits = 0x01 << 16 //  GPIOD reset.
	GPIOERST AHBRSTR_Bits = 0x01 << 21 //+ GPIOE reset.
	GPIOFRST AHBRSTR_Bits = 0x01 << 22 //+ GPIOF reset.
	GPIOGRST AHBRSTR_Bits = 0x01 << 23 //+ GPIOG reset.
	TSRST    AHBRSTR_Bits = 0x01 << 20 //+ TS reset.
	ADC12RST AHBRSTR_Bits = 0x01 << 24 //+ ADC1 & ADC2 reset.
	ADC34RST AHBRSTR_Bits = 0x01 << 25 //+ ADC3 & ADC4 reset.
)

const (
	FMCRSTn   = 5
	GPIOHRSTn = 16
	GPIOARSTn = 17
	GPIOBRSTn = 18
	GPIOCRSTn = 19
	GPIOERSTn = 21
	GPIOFRSTn = 22
	GPIOGRSTn = 23
	TSRSTn    = 20
	ADC12RSTn = 24
	ADC34RSTn = 25
)

const (
	PREDIV1         CFGR2_Bits = 0x0F << 0 //+ PREDIV1[3:0] bits.
	PREDIV1_0       CFGR2_Bits = 0x01 << 0 //  Bit 0.
	PREDIV1_1       CFGR2_Bits = 0x02 << 0 //  Bit 1.
	PREDIV1_2       CFGR2_Bits = 0x04 << 0 //  Bit 2.
	PREDIV1_3       CFGR2_Bits = 0x08 << 0 //  Bit 3.
	PREDIV1_DIV1    CFGR2_Bits = 0x00 << 0 //  PREDIV1 input clock not divided.
	PREDIV1_DIV2    CFGR2_Bits = 0x01 << 0 //  PREDIV1 input clock divided by 2.
	PREDIV1_DIV3    CFGR2_Bits = 0x02 << 0 //  PREDIV1 input clock divided by 3.
	PREDIV1_DIV4    CFGR2_Bits = 0x03 << 0 //  PREDIV1 input clock divided by 4.
	PREDIV1_DIV5    CFGR2_Bits = 0x04 << 0 //  PREDIV1 input clock divided by 5.
	PREDIV1_DIV6    CFGR2_Bits = 0x05 << 0 //  PREDIV1 input clock divided by 6.
	PREDIV1_DIV7    CFGR2_Bits = 0x06 << 0 //  PREDIV1 input clock divided by 7.
	PREDIV1_DIV8    CFGR2_Bits = 0x07 << 0 //  PREDIV1 input clock divided by 8.
	PREDIV1_DIV9    CFGR2_Bits = 0x08 << 0 //  PREDIV1 input clock divided by 9.
	PREDIV1_DIV10   CFGR2_Bits = 0x09 << 0 //  PREDIV1 input clock divided by 10.
	PREDIV1_DIV11   CFGR2_Bits = 0x0A << 0 //  PREDIV1 input clock divided by 11.
	PREDIV1_DIV12   CFGR2_Bits = 0x0B << 0 //  PREDIV1 input clock divided by 12.
	PREDIV1_DIV13   CFGR2_Bits = 0x0C << 0 //  PREDIV1 input clock divided by 13.
	PREDIV1_DIV14   CFGR2_Bits = 0x0D << 0 //  PREDIV1 input clock divided by 14.
	PREDIV1_DIV15   CFGR2_Bits = 0x0E << 0 //  PREDIV1 input clock divided by 15.
	PREDIV1_DIV16   CFGR2_Bits = 0x0F << 0 //  PREDIV1 input clock divided by 16.
	ADCPRE12        CFGR2_Bits = 0x1F << 4 //+ ADCPRE12[8:4] bits.
	ADCPRE12_0      CFGR2_Bits = 0x01 << 4 //  Bit 0.
	ADCPRE12_1      CFGR2_Bits = 0x02 << 4 //  Bit 1.
	ADCPRE12_2      CFGR2_Bits = 0x04 << 4 //  Bit 2.
	ADCPRE12_3      CFGR2_Bits = 0x08 << 4 //  Bit 3.
	ADCPRE12_4      CFGR2_Bits = 0x10 << 4 //  Bit 4.
	ADCPRE12_NO     CFGR2_Bits = 0x00 << 4 //  ADC12 clock disabled, ADC12 can use AHB clock.
	ADCPRE12_DIV1   CFGR2_Bits = 0x10 << 4 //  ADC12 PLL clock divided by 1.
	ADCPRE12_DIV2   CFGR2_Bits = 0x11 << 4 //  ADC12 PLL clock divided by 2.
	ADCPRE12_DIV4   CFGR2_Bits = 0x12 << 4 //  ADC12 PLL clock divided by 4.
	ADCPRE12_DIV6   CFGR2_Bits = 0x13 << 4 //  ADC12 PLL clock divided by 6.
	ADCPRE12_DIV8   CFGR2_Bits = 0x14 << 4 //  ADC12 PLL clock divided by 8.
	ADCPRE12_DIV10  CFGR2_Bits = 0x15 << 4 //  ADC12 PLL clock divided by 10.
	ADCPRE12_DIV12  CFGR2_Bits = 0x16 << 4 //  ADC12 PLL clock divided by 12.
	ADCPRE12_DIV16  CFGR2_Bits = 0x17 << 4 //  ADC12 PLL clock divided by 16.
	ADCPRE12_DIV32  CFGR2_Bits = 0x18 << 4 //  ADC12 PLL clock divided by 32.
	ADCPRE12_DIV64  CFGR2_Bits = 0x19 << 4 //  ADC12 PLL clock divided by 64.
	ADCPRE12_DIV128 CFGR2_Bits = 0x1A << 4 //  ADC12 PLL clock divided by 128.
	ADCPRE12_DIV256 CFGR2_Bits = 0x1B << 4 //  ADC12 PLL clock divided by 256.
	ADCPRE34        CFGR2_Bits = 0x1F << 9 //+ ADCPRE34[13:5] bits.
	ADCPRE34_0      CFGR2_Bits = 0x01 << 9 //  Bit 0.
	ADCPRE34_1      CFGR2_Bits = 0x02 << 9 //  Bit 1.
	ADCPRE34_2      CFGR2_Bits = 0x04 << 9 //  Bit 2.
	ADCPRE34_3      CFGR2_Bits = 0x08 << 9 //  Bit 3.
	ADCPRE34_4      CFGR2_Bits = 0x10 << 9 //  Bit 4.
	ADCPRE34_NO     CFGR2_Bits = 0x00 << 9 //  ADC34 clock disabled, ADC34 can use AHB clock.
	ADCPRE34_DIV1   CFGR2_Bits = 0x10 << 9 //  ADC34 PLL clock divided by 1.
	ADCPRE34_DIV2   CFGR2_Bits = 0x11 << 9 //  ADC34 PLL clock divided by 2.
	ADCPRE34_DIV4   CFGR2_Bits = 0x12 << 9 //  ADC34 PLL clock divided by 4.
	ADCPRE34_DIV6   CFGR2_Bits = 0x13 << 9 //  ADC34 PLL clock divided by 6.
	ADCPRE34_DIV8   CFGR2_Bits = 0x14 << 9 //  ADC34 PLL clock divided by 8.
	ADCPRE34_DIV10  CFGR2_Bits = 0x15 << 9 //  ADC34 PLL clock divided by 10.
	ADCPRE34_DIV12  CFGR2_Bits = 0x16 << 9 //  ADC34 PLL clock divided by 12.
	ADCPRE34_DIV16  CFGR2_Bits = 0x17 << 9 //  ADC34 PLL clock divided by 16.
	ADCPRE34_DIV32  CFGR2_Bits = 0x18 << 9 //  ADC34 PLL clock divided by 32.
	ADCPRE34_DIV64  CFGR2_Bits = 0x19 << 9 //  ADC34 PLL clock divided by 64.
	ADCPRE34_DIV128 CFGR2_Bits = 0x1A << 9 //  ADC34 PLL clock divided by 128.
	ADCPRE34_DIV256 CFGR2_Bits = 0x1B << 9 //  ADC34 PLL clock divided by 256.
)

const (
	PREDIV1n  = 0
	ADCPRE12n = 4
	ADCPRE34n = 9
)

const (
	USART1SW   CFGR3_Bits = 0x03 << 0  //+ USART1SW[1:0] bits.
	USART1SW_0 CFGR3_Bits = 0x01 << 0  //  Bit 0.
	USART1SW_1 CFGR3_Bits = 0x02 << 0  //  Bit 1.
	I2CSW      CFGR3_Bits = 0x07 << 4  //+ I2CSW bits.
	I2C1SW     CFGR3_Bits = 0x01 << 4  //  I2C1SW bits.
	I2C2SW     CFGR3_Bits = 0x02 << 4  //  I2C2SW bits.
	I2C3SW     CFGR3_Bits = 0x04 << 4  //  I2C3SW bits.
	TIMSW      CFGR3_Bits = 0x2F << 8  //+ TIMSW bits.
	TIM1SW     CFGR3_Bits = 0x01 << 8  //  TIM1SW bits.
	TIM8SW     CFGR3_Bits = 0x02 << 8  //  TIM8SW bits.
	TIM15SW    CFGR3_Bits = 0x04 << 8  //  TIM15SW bits.
	TIM16SW    CFGR3_Bits = 0x08 << 8  //  TIM16SW bits.
	TIM17SW    CFGR3_Bits = 0x20 << 8  //  TIM17SW bits.
	TIM20SW    CFGR3_Bits = 0x01 << 15 //+ TIM20SW bits.
	TIM2SW     CFGR3_Bits = 0x01 << 24 //+ TIM3SW bits.
	TIM3SW     CFGR3_Bits = 0x01 << 25 //+ TIM2SW bits.
	HRTIM1SW   CFGR3_Bits = 0x01 << 12 //+ HRTIM1SW bits.
	USART2SW   CFGR3_Bits = 0x03 << 16 //+ USART2SW[1:0] bits.
	USART2SW_0 CFGR3_Bits = 0x01 << 16 //  Bit 0.
	USART2SW_1 CFGR3_Bits = 0x02 << 16 //  Bit 1.
	USART3SW   CFGR3_Bits = 0x03 << 18 //+ USART3SW[1:0] bits.
	USART3SW_0 CFGR3_Bits = 0x01 << 18 //  Bit 0.
	USART3SW_1 CFGR3_Bits = 0x02 << 18 //  Bit 1.
	UART4SW    CFGR3_Bits = 0x03 << 20 //+ UART4SW[1:0] bits.
	UART4SW_0  CFGR3_Bits = 0x01 << 20 //  Bit 0.
	UART4SW_1  CFGR3_Bits = 0x02 << 20 //  Bit 1.
	UART5SW    CFGR3_Bits = 0x03 << 22 //+ UART5SW[1:0] bits.
	UART5SW_0  CFGR3_Bits = 0x01 << 22 //  Bit 0.
	UART5SW_1  CFGR3_Bits = 0x02 << 22 //  Bit 1.
)

const (
	USART1SWn = 0
	I2CSWn    = 4
	TIMSWn    = 8
	TIM20SWn  = 15
	TIM2SWn   = 24
	TIM3SWn   = 25
	HRTIM1SWn = 12
	USART2SWn = 16
	USART3SWn = 18
	UART4SWn  = 20
	UART5SWn  = 22
)
