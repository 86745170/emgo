package fmc

// DO NOT EDIT THIS FILE. GENERATED BY xgen.

import (
	"bits"
	"mmio"
	"unsafe"

	"stm32/o/f303xe/mmap"
)

type FMC_Bank2_3_Periph struct {
	PCR2  RPCR2
	SR2   RSR2
	PMEM2 RPMEM2
	PATT2 RPATT2
	_     uint32
	ECCR2 RECCR2
	_     [2]uint32
	PCR3  RPCR3
	SR3   RSR3
	PMEM3 RPMEM3
	PATT3 RPATT3
	_     uint32
	ECCR3 RECCR3
}

func (p *FMC_Bank2_3_Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

//emgo:const
var FMC_Bank2_3 = (*FMC_Bank2_3_Periph)(unsafe.Pointer(uintptr(mmap.FMC_Bank2_3_R_BASE)))

type PCR2 uint32

func (b PCR2) Field(mask PCR2) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask PCR2) J(v int) PCR2 {
	return PCR2(bits.Make32(v, uint32(mask)))
}

type RPCR2 struct{ mmio.U32 }

func (r *RPCR2) Bits(mask PCR2) PCR2    { return PCR2(r.U32.Bits(uint32(mask))) }
func (r *RPCR2) StoreBits(mask, b PCR2) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPCR2) SetBits(mask PCR2)      { r.U32.SetBits(uint32(mask)) }
func (r *RPCR2) ClearBits(mask PCR2)    { r.U32.ClearBits(uint32(mask)) }
func (r *RPCR2) Load() PCR2             { return PCR2(r.U32.Load()) }
func (r *RPCR2) Store(b PCR2)           { r.U32.Store(uint32(b)) }

func (r *RPCR2) AtomicStoreBits(mask, b PCR2) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RPCR2) AtomicSetBits(mask PCR2)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RPCR2) AtomicClearBits(mask PCR2)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMPCR2 struct{ mmio.UM32 }

func (rm RMPCR2) Load() PCR2   { return PCR2(rm.UM32.Load()) }
func (rm RMPCR2) Store(b PCR2) { rm.UM32.Store(uint32(b)) }

func (p *FMC_Bank2_3_Periph) PWAITEN() RMPCR2 {
	return RMPCR2{mmio.UM32{&p.PCR2.U32, uint32(PWAITEN)}}
}

func (p *FMC_Bank2_3_Periph) PBKEN() RMPCR2 {
	return RMPCR2{mmio.UM32{&p.PCR2.U32, uint32(PBKEN)}}
}

func (p *FMC_Bank2_3_Periph) PTYP() RMPCR2 {
	return RMPCR2{mmio.UM32{&p.PCR2.U32, uint32(PTYP)}}
}

func (p *FMC_Bank2_3_Periph) PWID() RMPCR2 {
	return RMPCR2{mmio.UM32{&p.PCR2.U32, uint32(PWID)}}
}

func (p *FMC_Bank2_3_Periph) ECCEN() RMPCR2 {
	return RMPCR2{mmio.UM32{&p.PCR2.U32, uint32(ECCEN)}}
}

func (p *FMC_Bank2_3_Periph) TCLR() RMPCR2 {
	return RMPCR2{mmio.UM32{&p.PCR2.U32, uint32(TCLR)}}
}

func (p *FMC_Bank2_3_Periph) TAR() RMPCR2 {
	return RMPCR2{mmio.UM32{&p.PCR2.U32, uint32(TAR)}}
}

func (p *FMC_Bank2_3_Periph) ECCPS() RMPCR2 {
	return RMPCR2{mmio.UM32{&p.PCR2.U32, uint32(ECCPS)}}
}

type SR2 uint32

func (b SR2) Field(mask SR2) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask SR2) J(v int) SR2 {
	return SR2(bits.Make32(v, uint32(mask)))
}

type RSR2 struct{ mmio.U32 }

func (r *RSR2) Bits(mask SR2) SR2     { return SR2(r.U32.Bits(uint32(mask))) }
func (r *RSR2) StoreBits(mask, b SR2) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RSR2) SetBits(mask SR2)      { r.U32.SetBits(uint32(mask)) }
func (r *RSR2) ClearBits(mask SR2)    { r.U32.ClearBits(uint32(mask)) }
func (r *RSR2) Load() SR2             { return SR2(r.U32.Load()) }
func (r *RSR2) Store(b SR2)           { r.U32.Store(uint32(b)) }

func (r *RSR2) AtomicStoreBits(mask, b SR2) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RSR2) AtomicSetBits(mask SR2)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RSR2) AtomicClearBits(mask SR2)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMSR2 struct{ mmio.UM32 }

func (rm RMSR2) Load() SR2   { return SR2(rm.UM32.Load()) }
func (rm RMSR2) Store(b SR2) { rm.UM32.Store(uint32(b)) }

func (p *FMC_Bank2_3_Periph) IRS() RMSR2 {
	return RMSR2{mmio.UM32{&p.SR2.U32, uint32(IRS)}}
}

func (p *FMC_Bank2_3_Periph) ILS() RMSR2 {
	return RMSR2{mmio.UM32{&p.SR2.U32, uint32(ILS)}}
}

func (p *FMC_Bank2_3_Periph) IFS() RMSR2 {
	return RMSR2{mmio.UM32{&p.SR2.U32, uint32(IFS)}}
}

func (p *FMC_Bank2_3_Periph) IREN() RMSR2 {
	return RMSR2{mmio.UM32{&p.SR2.U32, uint32(IREN)}}
}

func (p *FMC_Bank2_3_Periph) ILEN() RMSR2 {
	return RMSR2{mmio.UM32{&p.SR2.U32, uint32(ILEN)}}
}

func (p *FMC_Bank2_3_Periph) IFEN() RMSR2 {
	return RMSR2{mmio.UM32{&p.SR2.U32, uint32(IFEN)}}
}

func (p *FMC_Bank2_3_Periph) FEMPT() RMSR2 {
	return RMSR2{mmio.UM32{&p.SR2.U32, uint32(FEMPT)}}
}

type PMEM2 uint32

func (b PMEM2) Field(mask PMEM2) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask PMEM2) J(v int) PMEM2 {
	return PMEM2(bits.Make32(v, uint32(mask)))
}

type RPMEM2 struct{ mmio.U32 }

func (r *RPMEM2) Bits(mask PMEM2) PMEM2   { return PMEM2(r.U32.Bits(uint32(mask))) }
func (r *RPMEM2) StoreBits(mask, b PMEM2) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPMEM2) SetBits(mask PMEM2)      { r.U32.SetBits(uint32(mask)) }
func (r *RPMEM2) ClearBits(mask PMEM2)    { r.U32.ClearBits(uint32(mask)) }
func (r *RPMEM2) Load() PMEM2             { return PMEM2(r.U32.Load()) }
func (r *RPMEM2) Store(b PMEM2)           { r.U32.Store(uint32(b)) }

func (r *RPMEM2) AtomicStoreBits(mask, b PMEM2) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RPMEM2) AtomicSetBits(mask PMEM2)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RPMEM2) AtomicClearBits(mask PMEM2)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMPMEM2 struct{ mmio.UM32 }

func (rm RMPMEM2) Load() PMEM2   { return PMEM2(rm.UM32.Load()) }
func (rm RMPMEM2) Store(b PMEM2) { rm.UM32.Store(uint32(b)) }

func (p *FMC_Bank2_3_Periph) MEMSET2() RMPMEM2 {
	return RMPMEM2{mmio.UM32{&p.PMEM2.U32, uint32(MEMSET2)}}
}

func (p *FMC_Bank2_3_Periph) MEMWAIT2() RMPMEM2 {
	return RMPMEM2{mmio.UM32{&p.PMEM2.U32, uint32(MEMWAIT2)}}
}

func (p *FMC_Bank2_3_Periph) MEMHOLD2() RMPMEM2 {
	return RMPMEM2{mmio.UM32{&p.PMEM2.U32, uint32(MEMHOLD2)}}
}

func (p *FMC_Bank2_3_Periph) MEMHIZ2() RMPMEM2 {
	return RMPMEM2{mmio.UM32{&p.PMEM2.U32, uint32(MEMHIZ2)}}
}

type PATT2 uint32

func (b PATT2) Field(mask PATT2) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask PATT2) J(v int) PATT2 {
	return PATT2(bits.Make32(v, uint32(mask)))
}

type RPATT2 struct{ mmio.U32 }

func (r *RPATT2) Bits(mask PATT2) PATT2   { return PATT2(r.U32.Bits(uint32(mask))) }
func (r *RPATT2) StoreBits(mask, b PATT2) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPATT2) SetBits(mask PATT2)      { r.U32.SetBits(uint32(mask)) }
func (r *RPATT2) ClearBits(mask PATT2)    { r.U32.ClearBits(uint32(mask)) }
func (r *RPATT2) Load() PATT2             { return PATT2(r.U32.Load()) }
func (r *RPATT2) Store(b PATT2)           { r.U32.Store(uint32(b)) }

func (r *RPATT2) AtomicStoreBits(mask, b PATT2) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RPATT2) AtomicSetBits(mask PATT2)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RPATT2) AtomicClearBits(mask PATT2)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMPATT2 struct{ mmio.UM32 }

func (rm RMPATT2) Load() PATT2   { return PATT2(rm.UM32.Load()) }
func (rm RMPATT2) Store(b PATT2) { rm.UM32.Store(uint32(b)) }

func (p *FMC_Bank2_3_Periph) ATTSET2() RMPATT2 {
	return RMPATT2{mmio.UM32{&p.PATT2.U32, uint32(ATTSET2)}}
}

func (p *FMC_Bank2_3_Periph) ATTWAIT2() RMPATT2 {
	return RMPATT2{mmio.UM32{&p.PATT2.U32, uint32(ATTWAIT2)}}
}

func (p *FMC_Bank2_3_Periph) ATTHOLD2() RMPATT2 {
	return RMPATT2{mmio.UM32{&p.PATT2.U32, uint32(ATTHOLD2)}}
}

func (p *FMC_Bank2_3_Periph) ATTHIZ2() RMPATT2 {
	return RMPATT2{mmio.UM32{&p.PATT2.U32, uint32(ATTHIZ2)}}
}

type ECCR2 uint32

func (b ECCR2) Field(mask ECCR2) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask ECCR2) J(v int) ECCR2 {
	return ECCR2(bits.Make32(v, uint32(mask)))
}

type RECCR2 struct{ mmio.U32 }

func (r *RECCR2) Bits(mask ECCR2) ECCR2   { return ECCR2(r.U32.Bits(uint32(mask))) }
func (r *RECCR2) StoreBits(mask, b ECCR2) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RECCR2) SetBits(mask ECCR2)      { r.U32.SetBits(uint32(mask)) }
func (r *RECCR2) ClearBits(mask ECCR2)    { r.U32.ClearBits(uint32(mask)) }
func (r *RECCR2) Load() ECCR2             { return ECCR2(r.U32.Load()) }
func (r *RECCR2) Store(b ECCR2)           { r.U32.Store(uint32(b)) }

func (r *RECCR2) AtomicStoreBits(mask, b ECCR2) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RECCR2) AtomicSetBits(mask ECCR2)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RECCR2) AtomicClearBits(mask ECCR2)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMECCR2 struct{ mmio.UM32 }

func (rm RMECCR2) Load() ECCR2   { return ECCR2(rm.UM32.Load()) }
func (rm RMECCR2) Store(b ECCR2) { rm.UM32.Store(uint32(b)) }

func (p *FMC_Bank2_3_Periph) ECC2() RMECCR2 {
	return RMECCR2{mmio.UM32{&p.ECCR2.U32, uint32(ECC2)}}
}

type PCR3 uint32

func (b PCR3) Field(mask PCR3) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask PCR3) J(v int) PCR3 {
	return PCR3(bits.Make32(v, uint32(mask)))
}

type RPCR3 struct{ mmio.U32 }

func (r *RPCR3) Bits(mask PCR3) PCR3    { return PCR3(r.U32.Bits(uint32(mask))) }
func (r *RPCR3) StoreBits(mask, b PCR3) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPCR3) SetBits(mask PCR3)      { r.U32.SetBits(uint32(mask)) }
func (r *RPCR3) ClearBits(mask PCR3)    { r.U32.ClearBits(uint32(mask)) }
func (r *RPCR3) Load() PCR3             { return PCR3(r.U32.Load()) }
func (r *RPCR3) Store(b PCR3)           { r.U32.Store(uint32(b)) }

func (r *RPCR3) AtomicStoreBits(mask, b PCR3) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RPCR3) AtomicSetBits(mask PCR3)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RPCR3) AtomicClearBits(mask PCR3)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMPCR3 struct{ mmio.UM32 }

func (rm RMPCR3) Load() PCR3   { return PCR3(rm.UM32.Load()) }
func (rm RMPCR3) Store(b PCR3) { rm.UM32.Store(uint32(b)) }

func (p *FMC_Bank2_3_Periph) PWAITEN() RMPCR3 {
	return RMPCR3{mmio.UM32{&p.PCR3.U32, uint32(PWAITEN)}}
}

func (p *FMC_Bank2_3_Periph) PBKEN() RMPCR3 {
	return RMPCR3{mmio.UM32{&p.PCR3.U32, uint32(PBKEN)}}
}

func (p *FMC_Bank2_3_Periph) PTYP() RMPCR3 {
	return RMPCR3{mmio.UM32{&p.PCR3.U32, uint32(PTYP)}}
}

func (p *FMC_Bank2_3_Periph) PWID() RMPCR3 {
	return RMPCR3{mmio.UM32{&p.PCR3.U32, uint32(PWID)}}
}

func (p *FMC_Bank2_3_Periph) ECCEN() RMPCR3 {
	return RMPCR3{mmio.UM32{&p.PCR3.U32, uint32(ECCEN)}}
}

func (p *FMC_Bank2_3_Periph) TCLR() RMPCR3 {
	return RMPCR3{mmio.UM32{&p.PCR3.U32, uint32(TCLR)}}
}

func (p *FMC_Bank2_3_Periph) TAR() RMPCR3 {
	return RMPCR3{mmio.UM32{&p.PCR3.U32, uint32(TAR)}}
}

func (p *FMC_Bank2_3_Periph) ECCPS() RMPCR3 {
	return RMPCR3{mmio.UM32{&p.PCR3.U32, uint32(ECCPS)}}
}

type SR3 uint32

func (b SR3) Field(mask SR3) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask SR3) J(v int) SR3 {
	return SR3(bits.Make32(v, uint32(mask)))
}

type RSR3 struct{ mmio.U32 }

func (r *RSR3) Bits(mask SR3) SR3     { return SR3(r.U32.Bits(uint32(mask))) }
func (r *RSR3) StoreBits(mask, b SR3) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RSR3) SetBits(mask SR3)      { r.U32.SetBits(uint32(mask)) }
func (r *RSR3) ClearBits(mask SR3)    { r.U32.ClearBits(uint32(mask)) }
func (r *RSR3) Load() SR3             { return SR3(r.U32.Load()) }
func (r *RSR3) Store(b SR3)           { r.U32.Store(uint32(b)) }

func (r *RSR3) AtomicStoreBits(mask, b SR3) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RSR3) AtomicSetBits(mask SR3)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RSR3) AtomicClearBits(mask SR3)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMSR3 struct{ mmio.UM32 }

func (rm RMSR3) Load() SR3   { return SR3(rm.UM32.Load()) }
func (rm RMSR3) Store(b SR3) { rm.UM32.Store(uint32(b)) }

func (p *FMC_Bank2_3_Periph) IRS() RMSR3 {
	return RMSR3{mmio.UM32{&p.SR3.U32, uint32(IRS)}}
}

func (p *FMC_Bank2_3_Periph) ILS() RMSR3 {
	return RMSR3{mmio.UM32{&p.SR3.U32, uint32(ILS)}}
}

func (p *FMC_Bank2_3_Periph) IFS() RMSR3 {
	return RMSR3{mmio.UM32{&p.SR3.U32, uint32(IFS)}}
}

func (p *FMC_Bank2_3_Periph) IREN() RMSR3 {
	return RMSR3{mmio.UM32{&p.SR3.U32, uint32(IREN)}}
}

func (p *FMC_Bank2_3_Periph) ILEN() RMSR3 {
	return RMSR3{mmio.UM32{&p.SR3.U32, uint32(ILEN)}}
}

func (p *FMC_Bank2_3_Periph) IFEN() RMSR3 {
	return RMSR3{mmio.UM32{&p.SR3.U32, uint32(IFEN)}}
}

func (p *FMC_Bank2_3_Periph) FEMPT() RMSR3 {
	return RMSR3{mmio.UM32{&p.SR3.U32, uint32(FEMPT)}}
}

type PMEM3 uint32

func (b PMEM3) Field(mask PMEM3) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask PMEM3) J(v int) PMEM3 {
	return PMEM3(bits.Make32(v, uint32(mask)))
}

type RPMEM3 struct{ mmio.U32 }

func (r *RPMEM3) Bits(mask PMEM3) PMEM3   { return PMEM3(r.U32.Bits(uint32(mask))) }
func (r *RPMEM3) StoreBits(mask, b PMEM3) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPMEM3) SetBits(mask PMEM3)      { r.U32.SetBits(uint32(mask)) }
func (r *RPMEM3) ClearBits(mask PMEM3)    { r.U32.ClearBits(uint32(mask)) }
func (r *RPMEM3) Load() PMEM3             { return PMEM3(r.U32.Load()) }
func (r *RPMEM3) Store(b PMEM3)           { r.U32.Store(uint32(b)) }

func (r *RPMEM3) AtomicStoreBits(mask, b PMEM3) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RPMEM3) AtomicSetBits(mask PMEM3)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RPMEM3) AtomicClearBits(mask PMEM3)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMPMEM3 struct{ mmio.UM32 }

func (rm RMPMEM3) Load() PMEM3   { return PMEM3(rm.UM32.Load()) }
func (rm RMPMEM3) Store(b PMEM3) { rm.UM32.Store(uint32(b)) }

func (p *FMC_Bank2_3_Periph) MEMSET3() RMPMEM3 {
	return RMPMEM3{mmio.UM32{&p.PMEM3.U32, uint32(MEMSET3)}}
}

func (p *FMC_Bank2_3_Periph) MEMWAIT3() RMPMEM3 {
	return RMPMEM3{mmio.UM32{&p.PMEM3.U32, uint32(MEMWAIT3)}}
}

func (p *FMC_Bank2_3_Periph) MEMHOLD3() RMPMEM3 {
	return RMPMEM3{mmio.UM32{&p.PMEM3.U32, uint32(MEMHOLD3)}}
}

func (p *FMC_Bank2_3_Periph) MEMHIZ3() RMPMEM3 {
	return RMPMEM3{mmio.UM32{&p.PMEM3.U32, uint32(MEMHIZ3)}}
}

type PATT3 uint32

func (b PATT3) Field(mask PATT3) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask PATT3) J(v int) PATT3 {
	return PATT3(bits.Make32(v, uint32(mask)))
}

type RPATT3 struct{ mmio.U32 }

func (r *RPATT3) Bits(mask PATT3) PATT3   { return PATT3(r.U32.Bits(uint32(mask))) }
func (r *RPATT3) StoreBits(mask, b PATT3) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPATT3) SetBits(mask PATT3)      { r.U32.SetBits(uint32(mask)) }
func (r *RPATT3) ClearBits(mask PATT3)    { r.U32.ClearBits(uint32(mask)) }
func (r *RPATT3) Load() PATT3             { return PATT3(r.U32.Load()) }
func (r *RPATT3) Store(b PATT3)           { r.U32.Store(uint32(b)) }

func (r *RPATT3) AtomicStoreBits(mask, b PATT3) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RPATT3) AtomicSetBits(mask PATT3)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RPATT3) AtomicClearBits(mask PATT3)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMPATT3 struct{ mmio.UM32 }

func (rm RMPATT3) Load() PATT3   { return PATT3(rm.UM32.Load()) }
func (rm RMPATT3) Store(b PATT3) { rm.UM32.Store(uint32(b)) }

func (p *FMC_Bank2_3_Periph) ATTSET3() RMPATT3 {
	return RMPATT3{mmio.UM32{&p.PATT3.U32, uint32(ATTSET3)}}
}

func (p *FMC_Bank2_3_Periph) ATTWAIT3() RMPATT3 {
	return RMPATT3{mmio.UM32{&p.PATT3.U32, uint32(ATTWAIT3)}}
}

func (p *FMC_Bank2_3_Periph) ATTHOLD3() RMPATT3 {
	return RMPATT3{mmio.UM32{&p.PATT3.U32, uint32(ATTHOLD3)}}
}

func (p *FMC_Bank2_3_Periph) ATTHIZ3() RMPATT3 {
	return RMPATT3{mmio.UM32{&p.PATT3.U32, uint32(ATTHIZ3)}}
}

type ECCR3 uint32

func (b ECCR3) Field(mask ECCR3) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask ECCR3) J(v int) ECCR3 {
	return ECCR3(bits.Make32(v, uint32(mask)))
}

type RECCR3 struct{ mmio.U32 }

func (r *RECCR3) Bits(mask ECCR3) ECCR3   { return ECCR3(r.U32.Bits(uint32(mask))) }
func (r *RECCR3) StoreBits(mask, b ECCR3) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RECCR3) SetBits(mask ECCR3)      { r.U32.SetBits(uint32(mask)) }
func (r *RECCR3) ClearBits(mask ECCR3)    { r.U32.ClearBits(uint32(mask)) }
func (r *RECCR3) Load() ECCR3             { return ECCR3(r.U32.Load()) }
func (r *RECCR3) Store(b ECCR3)           { r.U32.Store(uint32(b)) }

func (r *RECCR3) AtomicStoreBits(mask, b ECCR3) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RECCR3) AtomicSetBits(mask ECCR3)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RECCR3) AtomicClearBits(mask ECCR3)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMECCR3 struct{ mmio.UM32 }

func (rm RMECCR3) Load() ECCR3   { return ECCR3(rm.UM32.Load()) }
func (rm RMECCR3) Store(b ECCR3) { rm.UM32.Store(uint32(b)) }

func (p *FMC_Bank2_3_Periph) ECC3() RMECCR3 {
	return RMECCR3{mmio.UM32{&p.ECCR3.U32, uint32(ECC3)}}
}
