// Peripheral: DFSDM_Filter_Periph  DFSDM module registers.
// Instances:
//  DFSDM1_Filter0  mmap.DFSDM1_Filter0_BASE
//  DFSDM1_Filter1  mmap.DFSDM1_Filter1_BASE
//  DFSDM1_Filter2  mmap.DFSDM1_Filter2_BASE
//  DFSDM1_Filter3  mmap.DFSDM1_Filter3_BASE
// Registers:
//  0x00 32  FLTCR1     DFSDM control register1.
//  0x04 32  FLTCR2     DFSDM control register2.
//  0x08 32  FLTISR     DFSDM interrupt and status register.
//  0x0C 32  FLTICR     DFSDM interrupt flag clear register.
//  0x10 32  FLTJCHGR   DFSDM injected channel group selection register.
//  0x14 32  FLTFCR     DFSDM filter control register.
//  0x18 32  FLTJDATAR  DFSDM data register for injected group.
//  0x1C 32  FLTRDATAR  DFSDM data register for regular group.
//  0x20 32  FLTAWHTR   DFSDM analog watchdog high threshold register.
//  0x24 32  FLTAWLTR   DFSDM analog watchdog low threshold register.
//  0x28 32  FLTAWSR    DFSDM analog watchdog status register.
//  0x2C 32  FLTAWCFR   DFSDM analog watchdog clear flag register.
//  0x30 32  FLTEXMAX   DFSDM extreme detector maximum register.
//  0x34 32  FLTEXMIN   DFSDM extreme detector minimum register.
//  0x38 32  FLTCNVTIMR DFSDM conversion timer.
// Import:
//  stm32/o/l476xx/mmap
package dfsdm

// DO NOT EDIT THIS FILE. GENERATED BY stm32xgen.

const (
	AWFSEL   FLTCR1_Bits = 0x01 << 30 //+ Analog watchdog fast mode select.
	FAST     FLTCR1_Bits = 0x01 << 29 //+ Fast conversion mode selection.
	RCH      FLTCR1_Bits = 0x07 << 24 //+ RCH[2:0] Regular channel selection.
	RDMAEN   FLTCR1_Bits = 0x01 << 21 //+ DMA channel enabled to read data for the regular conversion.
	RSYNC    FLTCR1_Bits = 0x01 << 19 //+ Launch regular conversion synchronously with DFSDMx.
	RCONT    FLTCR1_Bits = 0x01 << 18 //+ Continuous mode selection for regular conversions.
	RSWSTART FLTCR1_Bits = 0x01 << 17 //+ Software start of a conversion on the regular channel.
	JEXTEN   FLTCR1_Bits = 0x03 << 13 //+ JEXTEN[1:0] Trigger enable and trigger edge selection for injected conversions.
	JEXTSEL  FLTCR1_Bits = 0x07 << 8  //+ JEXTSEL[2:0]Trigger signal selection for launching injected conversions.
	JDMAEN   FLTCR1_Bits = 0x01 << 5  //+ DMA channel enabled to read data for the injected channel group.
	JSCAN    FLTCR1_Bits = 0x01 << 4  //+ Scanning conversion in continuous mode selection for injected conversions.
	JSYNC    FLTCR1_Bits = 0x01 << 3  //+ Launch an injected conversion synchronously with DFSDMx JSWSTART trigger.
	JSWSTART FLTCR1_Bits = 0x01 << 1  //+ Start the conversion of the injected group of channels.
	DFEN     FLTCR1_Bits = 0x01 << 0  //+ DFSDM enable.
)

const (
	AWFSELn   = 30
	FASTn     = 29
	RCHn      = 24
	RDMAENn   = 21
	RSYNCn    = 19
	RCONTn    = 18
	RSWSTARTn = 17
	JEXTENn   = 13
	JEXTSELn  = 8
	JDMAENn   = 5
	JSCANn    = 4
	JSYNCn    = 3
	JSWSTARTn = 1
	DFENn     = 0
)

const (
	AWDCH  FLTCR2_Bits = 0xFF << 16 //+ AWDCH[7:0] Analog watchdog channel selection.
	EXCH   FLTCR2_Bits = 0xFF << 8  //+ EXCH[7:0] Extreme detector channel selection.
	CKABIE FLTCR2_Bits = 0x01 << 6  //+ Clock absence interrupt enable.
	SCDIE  FLTCR2_Bits = 0x01 << 5  //+ Short circuit detector interrupt enable.
	AWDIE  FLTCR2_Bits = 0x01 << 4  //+ Analog watchdog interrupt enable.
	ROVRIE FLTCR2_Bits = 0x01 << 3  //+ Regular data overrun interrupt enable.
	JOVRIE FLTCR2_Bits = 0x01 << 2  //+ Injected data overrun interrupt enable.
	REOCIE FLTCR2_Bits = 0x01 << 1  //+ Regular end of conversion interrupt enable.
	JEOCIE FLTCR2_Bits = 0x01 << 0  //+ Injected end of conversion interrupt enable.
)

const (
	AWDCHn  = 16
	EXCHn   = 8
	CKABIEn = 6
	SCDIEn  = 5
	AWDIEn  = 4
	ROVRIEn = 3
	JOVRIEn = 2
	REOCIEn = 1
	JEOCIEn = 0
)

const (
	SCDF  FLTISR_Bits = 0xFF << 24 //+ SCDF[7:0] Short circuit detector flag.
	CKABF FLTISR_Bits = 0xFF << 16 //+ CKABF[7:0] Clock absence flag.
	RCIP  FLTISR_Bits = 0x01 << 14 //+ Regular conversion in progress status.
	JCIP  FLTISR_Bits = 0x01 << 13 //+ Injected conversion in progress status.
	AWDF  FLTISR_Bits = 0x01 << 4  //+ Analog watchdog.
	ROVRF FLTISR_Bits = 0x01 << 3  //+ Regular conversion overrun flag.
	JOVRF FLTISR_Bits = 0x01 << 2  //+ Injected conversion overrun flag.
	REOCF FLTISR_Bits = 0x01 << 1  //+ End of regular conversion flag.
	JEOCF FLTISR_Bits = 0x01 << 0  //+ End of injected conversion flag.
)

const (
	SCDFn  = 24
	CKABFn = 16
	RCIPn  = 14
	JCIPn  = 13
	AWDFn  = 4
	ROVRFn = 3
	JOVRFn = 2
	REOCFn = 1
	JEOCFn = 0
)

const (
	CLRSCSDF FLTICR_Bits = 0xFF << 24 //+ CLRSCSDF[7:0] Clear the short circuit detector flag.
	CLRCKABF FLTICR_Bits = 0xFF << 16 //+ CLRCKABF[7:0] Clear the clock absence flag.
	CLRROVRF FLTICR_Bits = 0x01 << 3  //+ Clear the regular conversion overrun flag.
	CLRJOVRF FLTICR_Bits = 0x01 << 2  //+ Clear the injected conversion overrun flag.
)

const (
	CLRSCSDFn = 24
	CLRCKABFn = 16
	CLRROVRFn = 3
	CLRJOVRFn = 2
)

const (
	JCHG FLTJCHGR_Bits = 0xFF << 0 //+ JCHG[7:0] Injected channel group selection.
)

const (
	JCHGn = 0
)

const (
	FORD FLTFCR_Bits = 0x07 << 29  //+ FORD[2:0] Sinc filter order.
	FOSR FLTFCR_Bits = 0x3FF << 16 //+ FOSR[9:0] Sinc filter oversampling ratio (decimation rate).
	IOSR FLTFCR_Bits = 0xFF << 0   //+ IOSR[7:0] Integrator oversampling ratio (averaging length).
)

const (
	FORDn = 29
	FOSRn = 16
	IOSRn = 0
)

const (
	JDATA   FLTJDATAR_Bits = 0xFFFFFF << 8 //+ JDATA[23:0] Injected group conversion data.
	JDATACH FLTJDATAR_Bits = 0x07 << 0     //+ JDATACH[2:0] Injected channel most recently converted.
)

const (
	JDATAn   = 8
	JDATACHn = 0
)

const (
	RDATA   FLTRDATAR_Bits = 0xFFFFFF << 8 //+ RDATA[23:0] Regular channel conversion data.
	RPEND   FLTRDATAR_Bits = 0x01 << 4     //+ RPEND Regular channel pending data.
	RDATACH FLTRDATAR_Bits = 0x07 << 0     //+ RDATACH[2:0] Regular channel most recently converted.
)

const (
	RDATAn   = 8
	RPENDn   = 4
	RDATACHn = 0
)

const (
	AWHT  FLTAWHTR_Bits = 0xFFFFFF << 8 //+ AWHT[23:0] Analog watchdog high threshold.
	BKAWH FLTAWHTR_Bits = 0x0F << 0     //+ BKAWH[3:0] Break signal assignment to analog watchdog high threshold event.
)

const (
	AWHTn  = 8
	BKAWHn = 0
)

const (
	AWLT  FLTAWLTR_Bits = 0xFFFFFF << 8 //+ AWLT[23:0] Analog watchdog low threshold.
	BKAWL FLTAWLTR_Bits = 0x0F << 0     //+ BKAWL[3:0] Break signal assignment to analog watchdog low threshold event.
)

const (
	AWLTn  = 8
	BKAWLn = 0
)

const (
	AWHTF FLTAWSR_Bits = 0xFF << 8 //+ AWHTF[15:8] Analog watchdog high threshold error on given channels.
	AWLTF FLTAWSR_Bits = 0xFF << 0 //+ AWLTF[7:0] Analog watchdog low threshold error on given channels.
)

const (
	AWHTFn = 8
	AWLTFn = 0
)

const (
	CLRAWHTF FLTAWCFR_Bits = 0xFF << 8 //+ CLRAWHTF[15:8] Clear the Analog watchdog high threshold flag.
	CLRAWLTF FLTAWCFR_Bits = 0xFF << 0 //+ CLRAWLTF[7:0] Clear the Analog watchdog low threshold flag.
)

const (
	CLRAWHTFn = 8
	CLRAWLTFn = 0
)

const (
	EXMAX   FLTEXMAX_Bits = 0xFFFFFF << 8 //+ EXMAX[23:0] Extreme detector maximum value.
	EXMAXCH FLTEXMAX_Bits = 0x07 << 0     //+ EXMAXCH[2:0] Extreme detector maximum data channel.
)

const (
	EXMAXn   = 8
	EXMAXCHn = 0
)

const (
	EXMIN   FLTEXMIN_Bits = 0xFFFFFF << 8 //+ EXMIN[23:0] Extreme detector minimum value.
	EXMINCH FLTEXMIN_Bits = 0x07 << 0     //+ EXMINCH[2:0] Extreme detector minimum data channel.
)

const (
	EXMINn   = 8
	EXMINCHn = 0
)

const (
	CNVCNT FLTCNVTIMR_Bits = 0xFFFFFFF << 4 //+ CNVCNT[27:0]: 28-bit timer counting conversion time.
)

const (
	CNVCNTn = 4
)
