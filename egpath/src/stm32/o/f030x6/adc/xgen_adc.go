package adc

// DO NOT EDIT THIS FILE. GENERATED BY xgen.

import (
	"bits"
	"mmio"
	"unsafe"

	"stm32/o/f030x6/mmap"
)

type ADC_Periph struct {
	ISR    RISR
	IER    RIER
	CR     RCR
	CFGR1  RCFGR1
	CFGR2  RCFGR2
	SMPR   RSMPR
	_      [2]uint32
	TR     RTR
	_      uint32
	CHSELR RCHSELR
	_      [5]uint32
	DR     RDR
}

func (p *ADC_Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

//emgo:const
var ADC1 = (*ADC_Periph)(unsafe.Pointer(uintptr(mmap.ADC1_BASE)))

type ISR uint32

func (b ISR) Field(mask ISR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask ISR) J(v int) ISR {
	return ISR(bits.Make32(v, uint32(mask)))
}

type RISR struct{ mmio.U32 }

func (r *RISR) Bits(mask ISR) ISR     { return ISR(r.U32.Bits(uint32(mask))) }
func (r *RISR) StoreBits(mask, b ISR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RISR) SetBits(mask ISR)      { r.U32.SetBits(uint32(mask)) }
func (r *RISR) ClearBits(mask ISR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RISR) Load() ISR             { return ISR(r.U32.Load()) }
func (r *RISR) Store(b ISR)           { r.U32.Store(uint32(b)) }

func (r *RISR) AtomicStoreBits(mask, b ISR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RISR) AtomicSetBits(mask ISR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RISR) AtomicClearBits(mask ISR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMISR struct{ mmio.UM32 }

func (rm RMISR) Load() ISR   { return ISR(rm.UM32.Load()) }
func (rm RMISR) Store(b ISR) { rm.UM32.Store(uint32(b)) }

func (p *ADC_Periph) ADRDY() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(ADRDY)}}
}

func (p *ADC_Periph) EOSMP() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(EOSMP)}}
}

func (p *ADC_Periph) EOC() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(EOC)}}
}

func (p *ADC_Periph) EOS() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(EOS)}}
}

func (p *ADC_Periph) OVR() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(OVR)}}
}

func (p *ADC_Periph) AWD1() RMISR {
	return RMISR{mmio.UM32{&p.ISR.U32, uint32(AWD1)}}
}

type IER uint32

func (b IER) Field(mask IER) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask IER) J(v int) IER {
	return IER(bits.Make32(v, uint32(mask)))
}

type RIER struct{ mmio.U32 }

func (r *RIER) Bits(mask IER) IER     { return IER(r.U32.Bits(uint32(mask))) }
func (r *RIER) StoreBits(mask, b IER) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RIER) SetBits(mask IER)      { r.U32.SetBits(uint32(mask)) }
func (r *RIER) ClearBits(mask IER)    { r.U32.ClearBits(uint32(mask)) }
func (r *RIER) Load() IER             { return IER(r.U32.Load()) }
func (r *RIER) Store(b IER)           { r.U32.Store(uint32(b)) }

func (r *RIER) AtomicStoreBits(mask, b IER) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RIER) AtomicSetBits(mask IER)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RIER) AtomicClearBits(mask IER)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMIER struct{ mmio.UM32 }

func (rm RMIER) Load() IER   { return IER(rm.UM32.Load()) }
func (rm RMIER) Store(b IER) { rm.UM32.Store(uint32(b)) }

func (p *ADC_Periph) ADRDYIEIE() RMIER {
	return RMIER{mmio.UM32{&p.IER.U32, uint32(ADRDYIEIE)}}
}

func (p *ADC_Periph) EOSMPIEIE() RMIER {
	return RMIER{mmio.UM32{&p.IER.U32, uint32(EOSMPIEIE)}}
}

func (p *ADC_Periph) EOCIEIE() RMIER {
	return RMIER{mmio.UM32{&p.IER.U32, uint32(EOCIEIE)}}
}

func (p *ADC_Periph) EOSIEIE() RMIER {
	return RMIER{mmio.UM32{&p.IER.U32, uint32(EOSIEIE)}}
}

func (p *ADC_Periph) OVRIEIE() RMIER {
	return RMIER{mmio.UM32{&p.IER.U32, uint32(OVRIEIE)}}
}

func (p *ADC_Periph) AWD1IEIE() RMIER {
	return RMIER{mmio.UM32{&p.IER.U32, uint32(AWD1IEIE)}}
}

type CR uint32

func (b CR) Field(mask CR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask CR) J(v int) CR {
	return CR(bits.Make32(v, uint32(mask)))
}

type RCR struct{ mmio.U32 }

func (r *RCR) Bits(mask CR) CR      { return CR(r.U32.Bits(uint32(mask))) }
func (r *RCR) StoreBits(mask, b CR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCR) SetBits(mask CR)      { r.U32.SetBits(uint32(mask)) }
func (r *RCR) ClearBits(mask CR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCR) Load() CR             { return CR(r.U32.Load()) }
func (r *RCR) Store(b CR)           { r.U32.Store(uint32(b)) }

func (r *RCR) AtomicStoreBits(mask, b CR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RCR) AtomicSetBits(mask CR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RCR) AtomicClearBits(mask CR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMCR struct{ mmio.UM32 }

func (rm RMCR) Load() CR   { return CR(rm.UM32.Load()) }
func (rm RMCR) Store(b CR) { rm.UM32.Store(uint32(b)) }

func (p *ADC_Periph) ADEN() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(ADEN)}}
}

func (p *ADC_Periph) ADDIS() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(ADDIS)}}
}

func (p *ADC_Periph) ADSTART() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(ADSTART)}}
}

func (p *ADC_Periph) ADSTP() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(ADSTP)}}
}

func (p *ADC_Periph) ADCAL() RMCR {
	return RMCR{mmio.UM32{&p.CR.U32, uint32(ADCAL)}}
}

type CFGR1 uint32

func (b CFGR1) Field(mask CFGR1) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask CFGR1) J(v int) CFGR1 {
	return CFGR1(bits.Make32(v, uint32(mask)))
}

type RCFGR1 struct{ mmio.U32 }

func (r *RCFGR1) Bits(mask CFGR1) CFGR1   { return CFGR1(r.U32.Bits(uint32(mask))) }
func (r *RCFGR1) StoreBits(mask, b CFGR1) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCFGR1) SetBits(mask CFGR1)      { r.U32.SetBits(uint32(mask)) }
func (r *RCFGR1) ClearBits(mask CFGR1)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCFGR1) Load() CFGR1             { return CFGR1(r.U32.Load()) }
func (r *RCFGR1) Store(b CFGR1)           { r.U32.Store(uint32(b)) }

func (r *RCFGR1) AtomicStoreBits(mask, b CFGR1) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RCFGR1) AtomicSetBits(mask CFGR1)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RCFGR1) AtomicClearBits(mask CFGR1)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMCFGR1 struct{ mmio.UM32 }

func (rm RMCFGR1) Load() CFGR1   { return CFGR1(rm.UM32.Load()) }
func (rm RMCFGR1) Store(b CFGR1) { rm.UM32.Store(uint32(b)) }

func (p *ADC_Periph) DMAEN() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(DMAEN)}}
}

func (p *ADC_Periph) DMACFG() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(DMACFG)}}
}

func (p *ADC_Periph) SCANDIR() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(SCANDIR)}}
}

func (p *ADC_Periph) RES() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(RES)}}
}

func (p *ADC_Periph) ALIGN() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(ALIGN)}}
}

func (p *ADC_Periph) EXTSEL() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(EXTSEL)}}
}

func (p *ADC_Periph) EXTEN() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(EXTEN)}}
}

func (p *ADC_Periph) OVRMOD() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(OVRMOD)}}
}

func (p *ADC_Periph) CONT() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(CONT)}}
}

func (p *ADC_Periph) WAIT() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(WAIT)}}
}

func (p *ADC_Periph) AUTOFF() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(AUTOFF)}}
}

func (p *ADC_Periph) DISCEN() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(DISCEN)}}
}

func (p *ADC_Periph) AWD1SGL() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(AWD1SGL)}}
}

func (p *ADC_Periph) AWD1EN() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(AWD1EN)}}
}

func (p *ADC_Periph) AWD1CH() RMCFGR1 {
	return RMCFGR1{mmio.UM32{&p.CFGR1.U32, uint32(AWD1CH)}}
}

type CFGR2 uint32

func (b CFGR2) Field(mask CFGR2) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask CFGR2) J(v int) CFGR2 {
	return CFGR2(bits.Make32(v, uint32(mask)))
}

type RCFGR2 struct{ mmio.U32 }

func (r *RCFGR2) Bits(mask CFGR2) CFGR2   { return CFGR2(r.U32.Bits(uint32(mask))) }
func (r *RCFGR2) StoreBits(mask, b CFGR2) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCFGR2) SetBits(mask CFGR2)      { r.U32.SetBits(uint32(mask)) }
func (r *RCFGR2) ClearBits(mask CFGR2)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCFGR2) Load() CFGR2             { return CFGR2(r.U32.Load()) }
func (r *RCFGR2) Store(b CFGR2)           { r.U32.Store(uint32(b)) }

func (r *RCFGR2) AtomicStoreBits(mask, b CFGR2) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RCFGR2) AtomicSetBits(mask CFGR2)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RCFGR2) AtomicClearBits(mask CFGR2)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMCFGR2 struct{ mmio.UM32 }

func (rm RMCFGR2) Load() CFGR2   { return CFGR2(rm.UM32.Load()) }
func (rm RMCFGR2) Store(b CFGR2) { rm.UM32.Store(uint32(b)) }

func (p *ADC_Periph) CKMODE() RMCFGR2 {
	return RMCFGR2{mmio.UM32{&p.CFGR2.U32, uint32(CKMODE)}}
}

type SMPR uint32

func (b SMPR) Field(mask SMPR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask SMPR) J(v int) SMPR {
	return SMPR(bits.Make32(v, uint32(mask)))
}

type RSMPR struct{ mmio.U32 }

func (r *RSMPR) Bits(mask SMPR) SMPR    { return SMPR(r.U32.Bits(uint32(mask))) }
func (r *RSMPR) StoreBits(mask, b SMPR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RSMPR) SetBits(mask SMPR)      { r.U32.SetBits(uint32(mask)) }
func (r *RSMPR) ClearBits(mask SMPR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RSMPR) Load() SMPR             { return SMPR(r.U32.Load()) }
func (r *RSMPR) Store(b SMPR)           { r.U32.Store(uint32(b)) }

func (r *RSMPR) AtomicStoreBits(mask, b SMPR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RSMPR) AtomicSetBits(mask SMPR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RSMPR) AtomicClearBits(mask SMPR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMSMPR struct{ mmio.UM32 }

func (rm RMSMPR) Load() SMPR   { return SMPR(rm.UM32.Load()) }
func (rm RMSMPR) Store(b SMPR) { rm.UM32.Store(uint32(b)) }

func (p *ADC_Periph) SMP() RMSMPR {
	return RMSMPR{mmio.UM32{&p.SMPR.U32, uint32(SMP)}}
}

type TR uint32

func (b TR) Field(mask TR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask TR) J(v int) TR {
	return TR(bits.Make32(v, uint32(mask)))
}

type RTR struct{ mmio.U32 }

func (r *RTR) Bits(mask TR) TR      { return TR(r.U32.Bits(uint32(mask))) }
func (r *RTR) StoreBits(mask, b TR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RTR) SetBits(mask TR)      { r.U32.SetBits(uint32(mask)) }
func (r *RTR) ClearBits(mask TR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RTR) Load() TR             { return TR(r.U32.Load()) }
func (r *RTR) Store(b TR)           { r.U32.Store(uint32(b)) }

func (r *RTR) AtomicStoreBits(mask, b TR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RTR) AtomicSetBits(mask TR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RTR) AtomicClearBits(mask TR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMTR struct{ mmio.UM32 }

func (rm RMTR) Load() TR   { return TR(rm.UM32.Load()) }
func (rm RMTR) Store(b TR) { rm.UM32.Store(uint32(b)) }

func (p *ADC_Periph) LT1() RMTR {
	return RMTR{mmio.UM32{&p.TR.U32, uint32(LT1)}}
}

func (p *ADC_Periph) HT1() RMTR {
	return RMTR{mmio.UM32{&p.TR.U32, uint32(HT1)}}
}

type CHSELR uint32

func (b CHSELR) Field(mask CHSELR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask CHSELR) J(v int) CHSELR {
	return CHSELR(bits.Make32(v, uint32(mask)))
}

type RCHSELR struct{ mmio.U32 }

func (r *RCHSELR) Bits(mask CHSELR) CHSELR  { return CHSELR(r.U32.Bits(uint32(mask))) }
func (r *RCHSELR) StoreBits(mask, b CHSELR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCHSELR) SetBits(mask CHSELR)      { r.U32.SetBits(uint32(mask)) }
func (r *RCHSELR) ClearBits(mask CHSELR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCHSELR) Load() CHSELR             { return CHSELR(r.U32.Load()) }
func (r *RCHSELR) Store(b CHSELR)           { r.U32.Store(uint32(b)) }

func (r *RCHSELR) AtomicStoreBits(mask, b CHSELR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RCHSELR) AtomicSetBits(mask CHSELR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RCHSELR) AtomicClearBits(mask CHSELR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMCHSELR struct{ mmio.UM32 }

func (rm RMCHSELR) Load() CHSELR   { return CHSELR(rm.UM32.Load()) }
func (rm RMCHSELR) Store(b CHSELR) { rm.UM32.Store(uint32(b)) }

func (p *ADC_Periph) CHSEL() RMCHSELR {
	return RMCHSELR{mmio.UM32{&p.CHSELR.U32, uint32(CHSEL)}}
}

type DR uint32

func (b DR) Field(mask DR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask DR) J(v int) DR {
	return DR(bits.Make32(v, uint32(mask)))
}

type RDR struct{ mmio.U32 }

func (r *RDR) Bits(mask DR) DR      { return DR(r.U32.Bits(uint32(mask))) }
func (r *RDR) StoreBits(mask, b DR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RDR) SetBits(mask DR)      { r.U32.SetBits(uint32(mask)) }
func (r *RDR) ClearBits(mask DR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RDR) Load() DR             { return DR(r.U32.Load()) }
func (r *RDR) Store(b DR)           { r.U32.Store(uint32(b)) }

func (r *RDR) AtomicStoreBits(mask, b DR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RDR) AtomicSetBits(mask DR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RDR) AtomicClearBits(mask DR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMDR struct{ mmio.UM32 }

func (rm RMDR) Load() DR   { return DR(rm.UM32.Load()) }
func (rm RMDR) Store(b DR) { rm.UM32.Store(uint32(b)) }

func (p *ADC_Periph) DATA() RMDR {
	return RMDR{mmio.UM32{&p.DR.U32, uint32(DATA)}}
}
