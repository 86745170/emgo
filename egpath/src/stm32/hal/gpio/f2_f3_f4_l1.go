// +build f40_41xxx f411xe l1xx_md l1xx_mdp l1xx_hd l1xx_xl

package gpio

import (
	"mmio"
)

type registers struct {
	moder   mmio.U32
	otyper  mmio.U32
	ospeedr mmio.U32
	pupdr   mmio.U32
	idr     mmio.U32
	odr     mmio.U32
	bsrr    mmio.U32
	lckr    mmio.U32
	afr     [2]mmio.U32
}

const (
	// Mode
	out   = 1
	alt   = 2
	altIn = 2
	ana   = 3

	// Pull
	pullUp   = 1
	pullDown = 2

	// Driver
	openDrain = 1
)

func enableClock(p *Port, lp bool) {
	n := pnum(p)
	enr().SetBit(n)
	if lp {
		lpenr().SetBit(n)
	} else {
		lpenr().ClearBit(n)
	}
	_ = enr().Load() // RCC delay (workaround for silicon bugs).
}

func setup(p *Port, n int, cfg *Config) {
	pos := uint(n * 2)
	p.otyper.StoreBit(n, int(cfg.Driver))
	p.ospeedr.StoreBits(3<<pos, uint32(int(cfg.Speed)-veryLow)<<pos)
	p.pupdr.StoreBits(3<<pos, uint32(cfg.Pull)<<pos)
	p.moder.StoreBits(3<<pos, uint32(cfg.Mode)<<pos)
}

type AltFunc byte

const (
	AF0 AltFunc = iota
	AF1
	AF2
	AF3
	AF4
	AF5
	AF6
	AF7
	AF8
	AF9
	AF10
	AF11
	AF12
	AF13
	AF14
	AF15

	System   = AF0  // Syste, function.
	EventOut = AF15 // Pulse generated by SEV instruction.
)

// SetAltFunc sets alternate function af for n-th pin..
func (p *Port) SetAltFunc(pins Pins, af AltFunc) {
	for n := uint(0); n < 16; n++ {
		if pins&(1<<n) != 0 {
			m := n >> 3 & 1
			o := n & 7 * 4
			p.afr[m].StoreBits(0xf<<o, uint32(af)<<o)
		}
	}
}
