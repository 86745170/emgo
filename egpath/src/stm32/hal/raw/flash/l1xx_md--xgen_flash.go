// +build l1xx_md

package flash

// DO NOT EDIT THIS FILE. GENERATED BY xgen.

import (
	"bits"
	"mmio"
	"unsafe"

	"stm32/o/l1xx_md/mmap"
)

type FLASH_Periph struct {
	ACR     RACR
	PECR    RPECR
	PDKEYR  RPDKEYR
	PEKEYR  RPEKEYR
	PRGKEYR RPRGKEYR
	OPTKEYR ROPTKEYR
	SR      RSR
	OBR     ROBR
	WRPR    RWRPR
	_       [23]uint32
	WRPR1   RWRPR1
	WRPR2   RWRPR2
	WRPR3   RWRPR3
}

func (p *FLASH_Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

//emgo:const
var FLASH = (*FLASH_Periph)(unsafe.Pointer(uintptr(mmap.FLASH_R_BASE)))

type ACR uint32

func (b ACR) Field(mask ACR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask ACR) J(v int) ACR {
	return ACR(bits.MakeField32(v, uint32(mask)))
}

type RACR struct{ mmio.U32 }

func (r *RACR) Bits(mask ACR) ACR     { return ACR(r.U32.Bits(uint32(mask))) }
func (r *RACR) StoreBits(mask, b ACR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RACR) SetBits(mask ACR)      { r.U32.SetBits(uint32(mask)) }
func (r *RACR) ClearBits(mask ACR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RACR) Load() ACR             { return ACR(r.U32.Load()) }
func (r *RACR) Store(b ACR)           { r.U32.Store(uint32(b)) }

func (r *RACR) AtomicStoreBits(mask, b ACR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RACR) AtomicSetBits(mask ACR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RACR) AtomicClearBits(mask ACR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMACR struct{ mmio.UM32 }

func (rm RMACR) Load() ACR   { return ACR(rm.UM32.Load()) }
func (rm RMACR) Store(b ACR) { rm.UM32.Store(uint32(b)) }

func (p *FLASH_Periph) LATENCY() RMACR {
	return RMACR{mmio.UM32{&p.ACR.U32, uint32(LATENCY)}}
}

func (p *FLASH_Periph) PRFTEN() RMACR {
	return RMACR{mmio.UM32{&p.ACR.U32, uint32(PRFTEN)}}
}

func (p *FLASH_Periph) ACC64() RMACR {
	return RMACR{mmio.UM32{&p.ACR.U32, uint32(ACC64)}}
}

func (p *FLASH_Periph) SLEEP_PD() RMACR {
	return RMACR{mmio.UM32{&p.ACR.U32, uint32(SLEEP_PD)}}
}

func (p *FLASH_Periph) RUN_PD() RMACR {
	return RMACR{mmio.UM32{&p.ACR.U32, uint32(RUN_PD)}}
}

type PECR uint32

func (b PECR) Field(mask PECR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask PECR) J(v int) PECR {
	return PECR(bits.MakeField32(v, uint32(mask)))
}

type RPECR struct{ mmio.U32 }

func (r *RPECR) Bits(mask PECR) PECR    { return PECR(r.U32.Bits(uint32(mask))) }
func (r *RPECR) StoreBits(mask, b PECR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPECR) SetBits(mask PECR)      { r.U32.SetBits(uint32(mask)) }
func (r *RPECR) ClearBits(mask PECR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RPECR) Load() PECR             { return PECR(r.U32.Load()) }
func (r *RPECR) Store(b PECR)           { r.U32.Store(uint32(b)) }

func (r *RPECR) AtomicStoreBits(mask, b PECR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RPECR) AtomicSetBits(mask PECR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RPECR) AtomicClearBits(mask PECR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMPECR struct{ mmio.UM32 }

func (rm RMPECR) Load() PECR   { return PECR(rm.UM32.Load()) }
func (rm RMPECR) Store(b PECR) { rm.UM32.Store(uint32(b)) }

func (p *FLASH_Periph) PELOCK() RMPECR {
	return RMPECR{mmio.UM32{&p.PECR.U32, uint32(PELOCK)}}
}

func (p *FLASH_Periph) PRGLOCK() RMPECR {
	return RMPECR{mmio.UM32{&p.PECR.U32, uint32(PRGLOCK)}}
}

func (p *FLASH_Periph) OPTLOCK() RMPECR {
	return RMPECR{mmio.UM32{&p.PECR.U32, uint32(OPTLOCK)}}
}

func (p *FLASH_Periph) PROG() RMPECR {
	return RMPECR{mmio.UM32{&p.PECR.U32, uint32(PROG)}}
}

func (p *FLASH_Periph) DATA() RMPECR {
	return RMPECR{mmio.UM32{&p.PECR.U32, uint32(DATA)}}
}

func (p *FLASH_Periph) FTDW() RMPECR {
	return RMPECR{mmio.UM32{&p.PECR.U32, uint32(FTDW)}}
}

func (p *FLASH_Periph) ERASE() RMPECR {
	return RMPECR{mmio.UM32{&p.PECR.U32, uint32(ERASE)}}
}

func (p *FLASH_Periph) FPRG() RMPECR {
	return RMPECR{mmio.UM32{&p.PECR.U32, uint32(FPRG)}}
}

func (p *FLASH_Periph) PARALLBANK() RMPECR {
	return RMPECR{mmio.UM32{&p.PECR.U32, uint32(PARALLBANK)}}
}

func (p *FLASH_Periph) EOPIE() RMPECR {
	return RMPECR{mmio.UM32{&p.PECR.U32, uint32(EOPIE)}}
}

func (p *FLASH_Periph) ERRIE() RMPECR {
	return RMPECR{mmio.UM32{&p.PECR.U32, uint32(ERRIE)}}
}

func (p *FLASH_Periph) OBL_LAUNCH() RMPECR {
	return RMPECR{mmio.UM32{&p.PECR.U32, uint32(OBL_LAUNCH)}}
}

type PDKEYR uint32

func (b PDKEYR) Field(mask PDKEYR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask PDKEYR) J(v int) PDKEYR {
	return PDKEYR(bits.MakeField32(v, uint32(mask)))
}

type RPDKEYR struct{ mmio.U32 }

func (r *RPDKEYR) Bits(mask PDKEYR) PDKEYR  { return PDKEYR(r.U32.Bits(uint32(mask))) }
func (r *RPDKEYR) StoreBits(mask, b PDKEYR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPDKEYR) SetBits(mask PDKEYR)      { r.U32.SetBits(uint32(mask)) }
func (r *RPDKEYR) ClearBits(mask PDKEYR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RPDKEYR) Load() PDKEYR             { return PDKEYR(r.U32.Load()) }
func (r *RPDKEYR) Store(b PDKEYR)           { r.U32.Store(uint32(b)) }

func (r *RPDKEYR) AtomicStoreBits(mask, b PDKEYR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RPDKEYR) AtomicSetBits(mask PDKEYR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RPDKEYR) AtomicClearBits(mask PDKEYR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMPDKEYR struct{ mmio.UM32 }

func (rm RMPDKEYR) Load() PDKEYR   { return PDKEYR(rm.UM32.Load()) }
func (rm RMPDKEYR) Store(b PDKEYR) { rm.UM32.Store(uint32(b)) }

type PEKEYR uint32

func (b PEKEYR) Field(mask PEKEYR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask PEKEYR) J(v int) PEKEYR {
	return PEKEYR(bits.MakeField32(v, uint32(mask)))
}

type RPEKEYR struct{ mmio.U32 }

func (r *RPEKEYR) Bits(mask PEKEYR) PEKEYR  { return PEKEYR(r.U32.Bits(uint32(mask))) }
func (r *RPEKEYR) StoreBits(mask, b PEKEYR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPEKEYR) SetBits(mask PEKEYR)      { r.U32.SetBits(uint32(mask)) }
func (r *RPEKEYR) ClearBits(mask PEKEYR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RPEKEYR) Load() PEKEYR             { return PEKEYR(r.U32.Load()) }
func (r *RPEKEYR) Store(b PEKEYR)           { r.U32.Store(uint32(b)) }

func (r *RPEKEYR) AtomicStoreBits(mask, b PEKEYR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RPEKEYR) AtomicSetBits(mask PEKEYR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RPEKEYR) AtomicClearBits(mask PEKEYR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMPEKEYR struct{ mmio.UM32 }

func (rm RMPEKEYR) Load() PEKEYR   { return PEKEYR(rm.UM32.Load()) }
func (rm RMPEKEYR) Store(b PEKEYR) { rm.UM32.Store(uint32(b)) }

type PRGKEYR uint32

func (b PRGKEYR) Field(mask PRGKEYR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask PRGKEYR) J(v int) PRGKEYR {
	return PRGKEYR(bits.MakeField32(v, uint32(mask)))
}

type RPRGKEYR struct{ mmio.U32 }

func (r *RPRGKEYR) Bits(mask PRGKEYR) PRGKEYR { return PRGKEYR(r.U32.Bits(uint32(mask))) }
func (r *RPRGKEYR) StoreBits(mask, b PRGKEYR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RPRGKEYR) SetBits(mask PRGKEYR)      { r.U32.SetBits(uint32(mask)) }
func (r *RPRGKEYR) ClearBits(mask PRGKEYR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RPRGKEYR) Load() PRGKEYR             { return PRGKEYR(r.U32.Load()) }
func (r *RPRGKEYR) Store(b PRGKEYR)           { r.U32.Store(uint32(b)) }

func (r *RPRGKEYR) AtomicStoreBits(mask, b PRGKEYR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RPRGKEYR) AtomicSetBits(mask PRGKEYR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RPRGKEYR) AtomicClearBits(mask PRGKEYR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMPRGKEYR struct{ mmio.UM32 }

func (rm RMPRGKEYR) Load() PRGKEYR   { return PRGKEYR(rm.UM32.Load()) }
func (rm RMPRGKEYR) Store(b PRGKEYR) { rm.UM32.Store(uint32(b)) }

type OPTKEYR uint32

func (b OPTKEYR) Field(mask OPTKEYR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask OPTKEYR) J(v int) OPTKEYR {
	return OPTKEYR(bits.MakeField32(v, uint32(mask)))
}

type ROPTKEYR struct{ mmio.U32 }

func (r *ROPTKEYR) Bits(mask OPTKEYR) OPTKEYR { return OPTKEYR(r.U32.Bits(uint32(mask))) }
func (r *ROPTKEYR) StoreBits(mask, b OPTKEYR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *ROPTKEYR) SetBits(mask OPTKEYR)      { r.U32.SetBits(uint32(mask)) }
func (r *ROPTKEYR) ClearBits(mask OPTKEYR)    { r.U32.ClearBits(uint32(mask)) }
func (r *ROPTKEYR) Load() OPTKEYR             { return OPTKEYR(r.U32.Load()) }
func (r *ROPTKEYR) Store(b OPTKEYR)           { r.U32.Store(uint32(b)) }

func (r *ROPTKEYR) AtomicStoreBits(mask, b OPTKEYR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *ROPTKEYR) AtomicSetBits(mask OPTKEYR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *ROPTKEYR) AtomicClearBits(mask OPTKEYR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMOPTKEYR struct{ mmio.UM32 }

func (rm RMOPTKEYR) Load() OPTKEYR   { return OPTKEYR(rm.UM32.Load()) }
func (rm RMOPTKEYR) Store(b OPTKEYR) { rm.UM32.Store(uint32(b)) }

type SR uint32

func (b SR) Field(mask SR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask SR) J(v int) SR {
	return SR(bits.MakeField32(v, uint32(mask)))
}

type RSR struct{ mmio.U32 }

func (r *RSR) Bits(mask SR) SR      { return SR(r.U32.Bits(uint32(mask))) }
func (r *RSR) StoreBits(mask, b SR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RSR) SetBits(mask SR)      { r.U32.SetBits(uint32(mask)) }
func (r *RSR) ClearBits(mask SR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RSR) Load() SR             { return SR(r.U32.Load()) }
func (r *RSR) Store(b SR)           { r.U32.Store(uint32(b)) }

func (r *RSR) AtomicStoreBits(mask, b SR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RSR) AtomicSetBits(mask SR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RSR) AtomicClearBits(mask SR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMSR struct{ mmio.UM32 }

func (rm RMSR) Load() SR   { return SR(rm.UM32.Load()) }
func (rm RMSR) Store(b SR) { rm.UM32.Store(uint32(b)) }

func (p *FLASH_Periph) BSY() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(BSY)}}
}

func (p *FLASH_Periph) EOP() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(EOP)}}
}

func (p *FLASH_Periph) ENHV() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(ENHV)}}
}

func (p *FLASH_Periph) READY() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(READY)}}
}

func (p *FLASH_Periph) WRPERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(WRPERR)}}
}

func (p *FLASH_Periph) PGAERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(PGAERR)}}
}

func (p *FLASH_Periph) SIZERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(SIZERR)}}
}

func (p *FLASH_Periph) OPTVERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(OPTVERR)}}
}

func (p *FLASH_Periph) OPTVERRUSR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(OPTVERRUSR)}}
}

func (p *FLASH_Periph) RDERR() RMSR {
	return RMSR{mmio.UM32{&p.SR.U32, uint32(RDERR)}}
}

type OBR uint32

func (b OBR) Field(mask OBR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask OBR) J(v int) OBR {
	return OBR(bits.MakeField32(v, uint32(mask)))
}

type ROBR struct{ mmio.U32 }

func (r *ROBR) Bits(mask OBR) OBR     { return OBR(r.U32.Bits(uint32(mask))) }
func (r *ROBR) StoreBits(mask, b OBR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *ROBR) SetBits(mask OBR)      { r.U32.SetBits(uint32(mask)) }
func (r *ROBR) ClearBits(mask OBR)    { r.U32.ClearBits(uint32(mask)) }
func (r *ROBR) Load() OBR             { return OBR(r.U32.Load()) }
func (r *ROBR) Store(b OBR)           { r.U32.Store(uint32(b)) }

func (r *ROBR) AtomicStoreBits(mask, b OBR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *ROBR) AtomicSetBits(mask OBR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *ROBR) AtomicClearBits(mask OBR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMOBR struct{ mmio.UM32 }

func (rm RMOBR) Load() OBR   { return OBR(rm.UM32.Load()) }
func (rm RMOBR) Store(b OBR) { rm.UM32.Store(uint32(b)) }

func (p *FLASH_Periph) RDPRT() RMOBR {
	return RMOBR{mmio.UM32{&p.OBR.U32, uint32(RDPRT)}}
}

func (p *FLASH_Periph) SPRMOD() RMOBR {
	return RMOBR{mmio.UM32{&p.OBR.U32, uint32(SPRMOD)}}
}

func (p *FLASH_Periph) BOR_LEV() RMOBR {
	return RMOBR{mmio.UM32{&p.OBR.U32, uint32(BOR_LEV)}}
}

func (p *FLASH_Periph) IWDG_SW() RMOBR {
	return RMOBR{mmio.UM32{&p.OBR.U32, uint32(IWDG_SW)}}
}

func (p *FLASH_Periph) nRST_STOP() RMOBR {
	return RMOBR{mmio.UM32{&p.OBR.U32, uint32(nRST_STOP)}}
}

func (p *FLASH_Periph) nRST_STDBY() RMOBR {
	return RMOBR{mmio.UM32{&p.OBR.U32, uint32(nRST_STDBY)}}
}

func (p *FLASH_Periph) BFB2() RMOBR {
	return RMOBR{mmio.UM32{&p.OBR.U32, uint32(BFB2)}}
}

type WRPR uint32

func (b WRPR) Field(mask WRPR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask WRPR) J(v int) WRPR {
	return WRPR(bits.MakeField32(v, uint32(mask)))
}

type RWRPR struct{ mmio.U32 }

func (r *RWRPR) Bits(mask WRPR) WRPR    { return WRPR(r.U32.Bits(uint32(mask))) }
func (r *RWRPR) StoreBits(mask, b WRPR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RWRPR) SetBits(mask WRPR)      { r.U32.SetBits(uint32(mask)) }
func (r *RWRPR) ClearBits(mask WRPR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RWRPR) Load() WRPR             { return WRPR(r.U32.Load()) }
func (r *RWRPR) Store(b WRPR)           { r.U32.Store(uint32(b)) }

func (r *RWRPR) AtomicStoreBits(mask, b WRPR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RWRPR) AtomicSetBits(mask WRPR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RWRPR) AtomicClearBits(mask WRPR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMWRPR struct{ mmio.UM32 }

func (rm RMWRPR) Load() WRPR   { return WRPR(rm.UM32.Load()) }
func (rm RMWRPR) Store(b WRPR) { rm.UM32.Store(uint32(b)) }

type WRPR1 uint32

func (b WRPR1) Field(mask WRPR1) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask WRPR1) J(v int) WRPR1 {
	return WRPR1(bits.MakeField32(v, uint32(mask)))
}

type RWRPR1 struct{ mmio.U32 }

func (r *RWRPR1) Bits(mask WRPR1) WRPR1   { return WRPR1(r.U32.Bits(uint32(mask))) }
func (r *RWRPR1) StoreBits(mask, b WRPR1) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RWRPR1) SetBits(mask WRPR1)      { r.U32.SetBits(uint32(mask)) }
func (r *RWRPR1) ClearBits(mask WRPR1)    { r.U32.ClearBits(uint32(mask)) }
func (r *RWRPR1) Load() WRPR1             { return WRPR1(r.U32.Load()) }
func (r *RWRPR1) Store(b WRPR1)           { r.U32.Store(uint32(b)) }

func (r *RWRPR1) AtomicStoreBits(mask, b WRPR1) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RWRPR1) AtomicSetBits(mask WRPR1)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RWRPR1) AtomicClearBits(mask WRPR1)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMWRPR1 struct{ mmio.UM32 }

func (rm RMWRPR1) Load() WRPR1   { return WRPR1(rm.UM32.Load()) }
func (rm RMWRPR1) Store(b WRPR1) { rm.UM32.Store(uint32(b)) }

type WRPR2 uint32

func (b WRPR2) Field(mask WRPR2) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask WRPR2) J(v int) WRPR2 {
	return WRPR2(bits.MakeField32(v, uint32(mask)))
}

type RWRPR2 struct{ mmio.U32 }

func (r *RWRPR2) Bits(mask WRPR2) WRPR2   { return WRPR2(r.U32.Bits(uint32(mask))) }
func (r *RWRPR2) StoreBits(mask, b WRPR2) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RWRPR2) SetBits(mask WRPR2)      { r.U32.SetBits(uint32(mask)) }
func (r *RWRPR2) ClearBits(mask WRPR2)    { r.U32.ClearBits(uint32(mask)) }
func (r *RWRPR2) Load() WRPR2             { return WRPR2(r.U32.Load()) }
func (r *RWRPR2) Store(b WRPR2)           { r.U32.Store(uint32(b)) }

func (r *RWRPR2) AtomicStoreBits(mask, b WRPR2) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RWRPR2) AtomicSetBits(mask WRPR2)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RWRPR2) AtomicClearBits(mask WRPR2)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMWRPR2 struct{ mmio.UM32 }

func (rm RMWRPR2) Load() WRPR2   { return WRPR2(rm.UM32.Load()) }
func (rm RMWRPR2) Store(b WRPR2) { rm.UM32.Store(uint32(b)) }

type WRPR3 uint32

func (b WRPR3) Field(mask WRPR3) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask WRPR3) J(v int) WRPR3 {
	return WRPR3(bits.MakeField32(v, uint32(mask)))
}

type RWRPR3 struct{ mmio.U32 }

func (r *RWRPR3) Bits(mask WRPR3) WRPR3   { return WRPR3(r.U32.Bits(uint32(mask))) }
func (r *RWRPR3) StoreBits(mask, b WRPR3) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RWRPR3) SetBits(mask WRPR3)      { r.U32.SetBits(uint32(mask)) }
func (r *RWRPR3) ClearBits(mask WRPR3)    { r.U32.ClearBits(uint32(mask)) }
func (r *RWRPR3) Load() WRPR3             { return WRPR3(r.U32.Load()) }
func (r *RWRPR3) Store(b WRPR3)           { r.U32.Store(uint32(b)) }

func (r *RWRPR3) AtomicStoreBits(mask, b WRPR3) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RWRPR3) AtomicSetBits(mask WRPR3)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RWRPR3) AtomicClearBits(mask WRPR3)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMWRPR3 struct{ mmio.UM32 }

func (rm RMWRPR3) Load() WRPR3   { return WRPR3(rm.UM32.Load()) }
func (rm RMWRPR3) Store(b WRPR3) { rm.UM32.Store(uint32(b)) }
