// Go code:
func F(a [4]byte) (r byte) {
	for k := range a {
		r += byte(k)
	}
	return
}
// C code:
// decl
struct $4_$byte_struct;
typedef struct $4_$byte_struct $4_$byte;
// def
#ifndef $4_$byte$
#define $4_$byte$
struct $4_$byte_struct {
	byte arr[4];
};
#endif
// decl
byte foo$F($4_$byte a$);
// def
byte foo$F($4_$byte a$) {
	byte r$ = 0;
	{
		{
			int k$ = 0;
			for (;k$ < 4; ++k$) {
				r$ += CAST(byte, k$);
			}
		}
		goto end;
	}
end:
	return r$;
}
// end

// Go code:
func F(a [4]byte) (r byte) {
	for k, _ := range a {
		r += byte(k)
	}
	return
}
// C code:
// decl
struct $4_$byte_struct;
typedef struct $4_$byte_struct $4_$byte;
// def
#ifndef $4_$byte$
#define $4_$byte$
struct $4_$byte_struct {
	byte arr[4];
};
#endif
// decl
byte foo$F($4_$byte a$);
// def
byte foo$F($4_$byte a$) {
	byte r$ = 0;
	{
		{
			int k$ = 0;
			for (;k$ < 4; ++k$) {
				r$ += CAST(byte, k$);
			}
		}
		goto end;
	}
end:
	return r$;
}
// end

// Go code:
func F(a [4]byte) (r byte) {
	for k, v := range a {
		if r > 4 {
			continue
		}
		r += byte(k) + v
	}
	return
}
// C code:
// decl
struct $4_$byte_struct;
typedef struct $4_$byte_struct $4_$byte;
// def
#ifndef $4_$byte$
#define $4_$byte$
struct $4_$byte_struct {
	byte arr[4];
};
#endif
// decl
byte foo$F($4_$byte a$);
// def
byte foo$F($4_$byte a$) {
	byte r$ = 0;
	{
		{
			int k$ = 0;
			for (;k$ < 4; ++k$) {
				byte v$ = AIDX(a$, k$);
				{
					if ((r$>4)) {
						continue;
					}
					r$ += (CAST(byte, k$)+v$);
				}
			}
		}
		goto end;
	}
end:
	return r$;
}
// end

// Go code:
func F(a [4]byte) (r byte) {
	for _, v := range a {
		if r > 4 {
			break
		}
		r += v
	}
	return
}
// C code:
// decl
struct $4_$byte_struct;
typedef struct $4_$byte_struct $4_$byte;
// def
#ifndef $4_$byte$
#define $4_$byte$
struct $4_$byte_struct {
	byte arr[4];
};
#endif
// decl
byte foo$F($4_$byte a$);
// def
byte foo$F($4_$byte a$) {
	byte r$ = 0;
	{
		{
			int _$ = 0;
			for (;_$ < 4; ++_$) {
				byte v$ = AIDX(a$, _$);
				{
					if ((r$>4)) {
						break;
					}
					r$ += v$;
				}
			}
		}
		goto end;
	}
end:
	return r$;
}
// end

// Go code:
func F(a [4]byte) (r byte) {
	for k := range a[1:] {
		r += byte(k)
	}
	return
}
// C code:
// decl
struct $4_$byte_struct;
typedef struct $4_$byte_struct $4_$byte;
// def
#ifndef $4_$byte$
#define $4_$byte$
struct $4_$byte_struct {
	byte arr[4];
};
#endif
// decl
byte foo$F($4_$byte a$);
// def
byte foo$F($4_$byte a$) {
	byte r$ = 0;
	{
		{
			slice _x = ASLICEL(4, a$, 1);
			int k$ = 0;
			for (;k$ < len(_x); ++k$) {
				r$ += CAST(byte, k$);
			}
		}
		goto end;
	}
end:
	return r$;
}
// end

// Go code:
func F(a [4]byte) (r byte) {
	for k, _ := range a[1:] {
		r += byte(k)
	}
	return
}
// C code:
// decl
struct $4_$byte_struct;
typedef struct $4_$byte_struct $4_$byte;
// def
#ifndef $4_$byte$
#define $4_$byte$
struct $4_$byte_struct {
	byte arr[4];
};
#endif
// decl
byte foo$F($4_$byte a$);
// def
byte foo$F($4_$byte a$) {
	byte r$ = 0;
	{
		{
			slice _x = ASLICEL(4, a$, 1);
			int k$ = 0;
			for (;k$ < len(_x); ++k$) {
				r$ += CAST(byte, k$);
			}
		}
		goto end;
	}
end:
	return r$;
}
// end

// Go code:
func F(a [4]byte) (r byte) {
loop:
	for k, v := range a[1:] {
		if r > 4 {
			continue loop
		}
		r += byte(k) + v
	}
	return
}
// C code:
// decl
struct $4_$byte_struct;
typedef struct $4_$byte_struct $4_$byte;
// def
#ifndef $4_$byte$
#define $4_$byte$
struct $4_$byte_struct {
	byte arr[4];
};
#endif
// decl
byte foo$F($4_$byte a$);
// def
byte foo$F($4_$byte a$) {
	byte r$ = 0;
	{
	loop$:;
		{
			slice _x = ASLICEL(4, a$, 1);
			int k$ = 0;
			for (;k$ < len(_x); ++k$) {
				byte v$ = SLIDX(byte*, _x, k$);
				{
					if ((r$>4)) {
						goto loop$_continue;
					}
					r$ += (CAST(byte, k$)+v$);
				}
			loop$_continue:;
			}
		}
	loop$_break:;
		goto end;
	}
end:
	return r$;
}
// end

// Go code:
func F(a [4]byte) (r byte) {
loop:
	for _, v := range a[1:] {
		if r > 4 {
			break loop
		}
		r += v
	}
	return
}
// C code:
// decl
struct $4_$byte_struct;
typedef struct $4_$byte_struct $4_$byte;
// def
#ifndef $4_$byte$
#define $4_$byte$
struct $4_$byte_struct {
	byte arr[4];
};
#endif
// decl
byte foo$F($4_$byte a$);
// def
byte foo$F($4_$byte a$) {
	byte r$ = 0;
	{
	loop$:;
		{
			slice _x = ASLICEL(4, a$, 1);
			int _$ = 0;
			for (;_$ < len(_x); ++_$) {
				byte v$ = SLIDX(byte*, _x, _$);
				{
					if ((r$>4)) {
						goto loop$_break;
					}
					r$ += v$;
				}
			loop$_continue:;
			}
		}
	loop$_break:;
		goto end;
	}
end:
	return r$;
}
// end

// Go code:
func F(a []byte) (r byte) {
loop:
	for range a[1:] {
		r++
		continue loop
	}
	return
}
// C code:
// decl
byte foo$F(slice a$);
// def
byte foo$F(slice a$) {
	byte r$ = 0;
	{
	loop$:;
		{
			slice _x = SLICEL(a$, byte*, 1);
			_$ = 0;
			for (;_$ < len(_x); ++_$) {
				{
					++(r$);
					goto loop$_continue;
				}
			loop$_continue:;
			}
		}
	loop$_break:;
		goto end;
	}
end:
	return r$;
}
// end

// Go code:
func F(c <-chan byte) (r byte) {
	for v := range c {
		r+= v
		continue
	}
	return
}
// C code:
// decl
struct byte$$bool_struct;
typedef struct byte$$bool_struct byte$$bool;
// def
#ifndef byte$$bool$
#define byte$$bool$
struct byte$$bool_struct {
	byte _0;
	bool _1;
};
#endif
// decl
byte foo$F(chan c$);
// def
byte foo$F(chan c$) {
	byte r$ = 0;
	{
		{
			for (;;) {
				byte$$bool _vok = RECVOK(byte$$bool, c$);
				if (!_vok._1) break;
				byte v$ = _vok._0;
				{
					r$ += v$;
					continue;
				}
			}
		}
		goto end;
	}
end:
	return r$;
}
// end

// Go code:
func F(c *<-chan byte) (r byte) {
loop:
	for v := range *c {
		r+= v
		continue loop
	}
	return
}
// C code:
// decl
struct byte$$bool_struct;
typedef struct byte$$bool_struct byte$$bool;
// def
#ifndef byte$$bool$
#define byte$$bool$
struct byte$$bool_struct {
	byte _0;
	bool _1;
};
#endif
// decl
byte foo$F(chan *c$);
// def
byte foo$F(chan *c$) {
	byte r$ = 0;
	{
	loop$:;
		{
			chan _x = *c$;
			for (;;) {
				byte$$bool _vok = RECVOK(byte$$bool, _x);
				if (!_vok._1) break;
				byte v$ = _vok._0;
				{
					r$ += v$;
					goto loop$_continue;
				}
			loop$_continue:;
			}
		}
	loop$_break:;
		goto end;
	}
end:
	return r$;
}
// end