// Go code:
type S struct {
	a, b int
}

var s S

func F() int {
	return s.a + s.b
}
// C code:
// decl
struct foo$S_struct;
typedef struct foo$S_struct foo$S;
// def
struct foo$S_struct {
	int a;
	int b;
};
// decl
foo$S foo$s;
// def
foo$S foo$s = {};
// decl
int foo$F();
// def
int foo$F() {
	return (foo$s.a+foo$s.b);
}
// end

// Go code:
var s struct{a, b int}

func F() int {
	return s.a + s.b
}
// C code:
// decl
struct {
	int a;
	int b;
} foo$s;
// def
struct {
	int a;
	int b;
} foo$s = {};
// decl
int foo$F();
// def
int foo$F() {
	return (foo$s.a+foo$s.b);
}
// end

// Go code:
type T int

func (t *T) Add(a T) {
	*t += a
}

func (t *T) F() func(T) {
	// This isn't correct Emgo code. t.Addr can't be
	// returned from F because it is implemented in C
	// as embeded function that refers to local variable t.
	// This will be correct when func will be simple
	// closure (planned in next-gen of gotoc) but now it is
	// simply a pointer to the function.
	return t.Add
}
// C code:
// decl
typedef int foo$T;
// decl
void foo$T$Add(foo$T *t$, foo$T a$);
// def
void foo$T$Add(foo$T *t$, foo$T a$) {
	*t$ += a$;
}
// decl
void foo$T$Add$0(ival* t$, foo$T a$);
// def
void foo$T$Add$0(ival* t$, foo$T a$) {
	return foo$T$Add((foo$T*)t$->ptr, a$);
}
// decl
void foo$T$Add$1(ival* t$, foo$T a$);
// def
void foo$T$Add$1(ival* t$, foo$T a$) {
	return foo$T$Add((foo$T*)t$, a$);
}
// decl
void (*foo$T$F(foo$T *t$))(foo$T);
// def
void (*foo$T$F(foo$T *t$))(foo$T) {
	return ({void func(foo$T _1) { return foo$T$Add(t$, _1); } func;});
}
// decl
void (*foo$T$F$0(ival* t$))(foo$T);
// def
void (*foo$T$F$0(ival* t$))(foo$T) {
	return foo$T$F((foo$T*)t$->ptr);
}
// decl
void (*foo$T$F$1(ival* t$))(foo$T);
// def
void (*foo$T$F$1(ival* t$))(foo$T) {
	return foo$T$F((foo$T*)t$);
}
// end

// Go code:
type T int

func (t *T) Add(a T) {
	*t += a
}

func F() func(*T, T) {
	return (*T).Add
}
// C code:
// decl
typedef int foo$T;
// decl
void foo$T$Add(foo$T *t$, foo$T a$);
// def
void foo$T$Add(foo$T *t$, foo$T a$) {
	*t$ += a$;
}
// decl
void foo$T$Add$0(ival* t$, foo$T a$);
// def
void foo$T$Add$0(ival* t$, foo$T a$) {
	return foo$T$Add((foo$T*)t$->ptr, a$);
}
// decl
void foo$T$Add$1(ival* t$, foo$T a$);
// def
void foo$T$Add$1(ival* t$, foo$T a$) {
	return foo$T$Add((foo$T*)t$, a$);
}
// decl
void (*foo$F())(foo$T*, foo$T);
// def
void (*foo$F())(foo$T*, foo$T) {
	return foo$T$Add;
}
// end

// Go code:
type A struct {
	Fa int
}

type B struct {
	A
	Fb int
}

func (a *A) F(b *B) {
	b.F(b)
}

// C code:
// decl
struct foo$A_struct;
typedef struct foo$A_struct foo$A;
// def
struct foo$A_struct {
	int Fa;
};
// decl
struct foo$B_struct;
typedef struct foo$B_struct foo$B;
// def
struct foo$B_struct {
	foo$A A;
	int Fb;
};
// decl
void foo$A$F(foo$A *a$, foo$B *b$);
// def
void foo$A$F(foo$A *a$, foo$B *b$) {
	foo$A$F(&b$->A, b$);
}
// decl
void foo$A$F$0(ival* a$, foo$B *b$);
// def
void foo$A$F$0(ival* a$, foo$B *b$) {
	return foo$A$F((foo$A*)a$->ptr, b$);
}
// decl
void foo$A$F$1(ival* a$, foo$B *b$);
// def
void foo$A$F$1(ival* a$, foo$B *b$) {
	return foo$A$F((foo$A*)a$, b$);
}
// end