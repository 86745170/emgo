// Package cmsttl implements tickless system clock using Cortex-M SysTick timer.
// SysTick does not provide tools to implement accurate tickless clock. Some
// hacks are need to use it this way. If you need tickless behavior use other,
// more suitable, timer if your system provides one.
package cmsttl

import (
	"math"
	"nbl"
	"sync/atomic"

	"arch/cortexm/scb"
	"arch/cortexm/systick"
)

const max = 1 << 24

var (
	counter nbl.Int64 // Time elapsed since timer start (nanoseconds).
	tocount uint64    // Number of ticks to generate PendSV.
	freqHz  uint      // Frequency of systick clock source.
	addns   uint32    // Correction.
)

// Setup setups SysTick to work as sytem clock.
//  hz       - frequency of SysTick clock source,
//  external - false: SysTick uses CPU clock; true: SysTick uses external clock.
func Setup(hz uint, external bool, fixns uint32) {
	freqHz = hz
	addns = fixns
	if hz == 0 {
		(systick.ENABLE | systick.TICKINT).Clear()
		return
	}
	tocount = 1<<64 - 1
	systick.RELOAD.Store(max - 1)
	systick.CURRENT.Clear()
	csr := systick.ENABLE | systick.TICKINT
	if !external {
		csr |= systick.CLKSOURCE
	}
	csr.Set()
}

var reload1 uint32 // Last reload + 1

// Uptime: see syscall.SetSysClock.
func Uptime() int64 {
	if freqHz == 0 {
		return 0
	}
	aba := counter.StartLoad()
	for {
		cnt := uint64(counter.TryLoad(aba))
		add := atomic.LoadUint32(&reload1) - systick.CURRENT.Load()
		var ok bool
		if aba, ok = counter.CheckLoad(aba); ok {
			return int64(math.Muldiv(cnt+uint64(add), 1e9, uint64(freqHz)))
		}
	}
}

var (
	sleepto int64
	newflag uint32
)

// SetWakeup: see syscall.SetSysClock.
func SetWakeup(t int64) {
	sleepto = t
	atomic.StoreUint32(&newflag, 1)
	scb.ICSR_Store(scb.PENDSTSET)
}

// SysTick interrupt can be generated by systick counter that had just reached
// zero or can be generated by SetWakeup function. Both reasons may occur
// simultaneously.
func sysTickHandler() {
	// Avoid fast reentering.
	systick.RELOAD.Store(max - 1)
	cnt := systick.CURRENT.Load()
	systick.CURRENT.Clear()

	if systick.COUNTFLAG.Load() != 0 {
		// Timer counted to zero.
		cnt = 0 // Can't rely on cnt value.
		scb.ICSR_Store(scb.PENDSVSET)
	}

	cnt = reload1 - cnt // Nuber of ticks counted by timer since last reload.

	if atomic.LoadUint32(&newflag) != 0 {
		// New sleepto value.
		//tocount =
	}

}

//c:__attribute__((section(".SysTick")))
var SysTickVector = sysTickHandler
