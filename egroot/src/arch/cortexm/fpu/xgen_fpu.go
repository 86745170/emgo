package fpu

// DO NOT EDIT THIS FILE. GENERATED BY xgen.

import (
	"bits"
	"mmio"
	"unsafe"
)

type FPU_Periph struct {
	CPACR  RCPACR
	_      [106]uint32
	FPCCR  RFPCCR
	FPCAR  RFPCAR
	FPDSCR RFPDSCR
}

func (p *FPU_Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

//emgo:const
var FPU = (*FPU_Periph)(unsafe.Pointer(uintptr(0xe000ED88)))

type CPACR uint32

func (b CPACR) Field(mask CPACR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask CPACR) J(v int) CPACR {
	return CPACR(bits.Make32(v, uint32(mask)))
}

type RCPACR struct{ mmio.U32 }

func (r *RCPACR) Bits(mask CPACR) CPACR   { return CPACR(r.U32.Bits(uint32(mask))) }
func (r *RCPACR) StoreBits(mask, b CPACR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RCPACR) SetBits(mask CPACR)      { r.U32.SetBits(uint32(mask)) }
func (r *RCPACR) ClearBits(mask CPACR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RCPACR) Load() CPACR             { return CPACR(r.U32.Load()) }
func (r *RCPACR) Store(b CPACR)           { r.U32.Store(uint32(b)) }

func (r *RCPACR) AtomicStoreBits(mask, b CPACR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RCPACR) AtomicSetBits(mask CPACR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RCPACR) AtomicClearBits(mask CPACR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMCPACR struct{ mmio.UM32 }

func (rm RMCPACR) Load() CPACR   { return CPACR(rm.UM32.Load()) }
func (rm RMCPACR) Store(b CPACR) { rm.UM32.Store(uint32(b)) }

func (p *FPU_Periph) CP10() RMCPACR {
	return RMCPACR{mmio.UM32{&p.CPACR.U32, uint32(CP10)}}
}

func (p *FPU_Periph) CP11() RMCPACR {
	return RMCPACR{mmio.UM32{&p.CPACR.U32, uint32(CP11)}}
}

type FPCCR uint32

func (b FPCCR) Field(mask FPCCR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask FPCCR) J(v int) FPCCR {
	return FPCCR(bits.Make32(v, uint32(mask)))
}

type RFPCCR struct{ mmio.U32 }

func (r *RFPCCR) Bits(mask FPCCR) FPCCR   { return FPCCR(r.U32.Bits(uint32(mask))) }
func (r *RFPCCR) StoreBits(mask, b FPCCR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RFPCCR) SetBits(mask FPCCR)      { r.U32.SetBits(uint32(mask)) }
func (r *RFPCCR) ClearBits(mask FPCCR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RFPCCR) Load() FPCCR             { return FPCCR(r.U32.Load()) }
func (r *RFPCCR) Store(b FPCCR)           { r.U32.Store(uint32(b)) }

func (r *RFPCCR) AtomicStoreBits(mask, b FPCCR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RFPCCR) AtomicSetBits(mask FPCCR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RFPCCR) AtomicClearBits(mask FPCCR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMFPCCR struct{ mmio.UM32 }

func (rm RMFPCCR) Load() FPCCR   { return FPCCR(rm.UM32.Load()) }
func (rm RMFPCCR) Store(b FPCCR) { rm.UM32.Store(uint32(b)) }

func (p *FPU_Periph) LSPACT() RMFPCCR {
	return RMFPCCR{mmio.UM32{&p.FPCCR.U32, uint32(LSPACT)}}
}

func (p *FPU_Periph) USER() RMFPCCR {
	return RMFPCCR{mmio.UM32{&p.FPCCR.U32, uint32(USER)}}
}

func (p *FPU_Periph) THREAD() RMFPCCR {
	return RMFPCCR{mmio.UM32{&p.FPCCR.U32, uint32(THREAD)}}
}

func (p *FPU_Periph) HFRDY() RMFPCCR {
	return RMFPCCR{mmio.UM32{&p.FPCCR.U32, uint32(HFRDY)}}
}

func (p *FPU_Periph) MMRDY() RMFPCCR {
	return RMFPCCR{mmio.UM32{&p.FPCCR.U32, uint32(MMRDY)}}
}

func (p *FPU_Periph) BFRDY() RMFPCCR {
	return RMFPCCR{mmio.UM32{&p.FPCCR.U32, uint32(BFRDY)}}
}

func (p *FPU_Periph) MONRDY() RMFPCCR {
	return RMFPCCR{mmio.UM32{&p.FPCCR.U32, uint32(MONRDY)}}
}

func (p *FPU_Periph) LSPEN() RMFPCCR {
	return RMFPCCR{mmio.UM32{&p.FPCCR.U32, uint32(LSPEN)}}
}

func (p *FPU_Periph) ASPEN() RMFPCCR {
	return RMFPCCR{mmio.UM32{&p.FPCCR.U32, uint32(ASPEN)}}
}

type FPCAR uint32

func (b FPCAR) Field(mask FPCAR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask FPCAR) J(v int) FPCAR {
	return FPCAR(bits.Make32(v, uint32(mask)))
}

type RFPCAR struct{ mmio.U32 }

func (r *RFPCAR) Bits(mask FPCAR) FPCAR   { return FPCAR(r.U32.Bits(uint32(mask))) }
func (r *RFPCAR) StoreBits(mask, b FPCAR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RFPCAR) SetBits(mask FPCAR)      { r.U32.SetBits(uint32(mask)) }
func (r *RFPCAR) ClearBits(mask FPCAR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RFPCAR) Load() FPCAR             { return FPCAR(r.U32.Load()) }
func (r *RFPCAR) Store(b FPCAR)           { r.U32.Store(uint32(b)) }

func (r *RFPCAR) AtomicStoreBits(mask, b FPCAR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RFPCAR) AtomicSetBits(mask FPCAR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RFPCAR) AtomicClearBits(mask FPCAR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMFPCAR struct{ mmio.UM32 }

func (rm RMFPCAR) Load() FPCAR   { return FPCAR(rm.UM32.Load()) }
func (rm RMFPCAR) Store(b FPCAR) { rm.UM32.Store(uint32(b)) }

func (p *FPU_Periph) ADDRESS() RMFPCAR {
	return RMFPCAR{mmio.UM32{&p.FPCAR.U32, uint32(ADDRESS)}}
}

type FPDSCR uint32

func (b FPDSCR) Field(mask FPDSCR) int {
	return bits.Field32(uint32(b), uint32(mask))
}
func (mask FPDSCR) J(v int) FPDSCR {
	return FPDSCR(bits.Make32(v, uint32(mask)))
}

type RFPDSCR struct{ mmio.U32 }

func (r *RFPDSCR) Bits(mask FPDSCR) FPDSCR  { return FPDSCR(r.U32.Bits(uint32(mask))) }
func (r *RFPDSCR) StoreBits(mask, b FPDSCR) { r.U32.StoreBits(uint32(mask), uint32(b)) }
func (r *RFPDSCR) SetBits(mask FPDSCR)      { r.U32.SetBits(uint32(mask)) }
func (r *RFPDSCR) ClearBits(mask FPDSCR)    { r.U32.ClearBits(uint32(mask)) }
func (r *RFPDSCR) Load() FPDSCR             { return FPDSCR(r.U32.Load()) }
func (r *RFPDSCR) Store(b FPDSCR)           { r.U32.Store(uint32(b)) }

func (r *RFPDSCR) AtomicStoreBits(mask, b FPDSCR) { r.U32.AtomicStoreBits(uint32(mask), uint32(b)) }
func (r *RFPDSCR) AtomicSetBits(mask FPDSCR)      { r.U32.AtomicSetBits(uint32(mask)) }
func (r *RFPDSCR) AtomicClearBits(mask FPDSCR)    { r.U32.AtomicClearBits(uint32(mask)) }

type RMFPDSCR struct{ mmio.UM32 }

func (rm RMFPDSCR) Load() FPDSCR   { return FPDSCR(rm.UM32.Load()) }
func (rm RMFPDSCR) Store(b FPDSCR) { rm.UM32.Store(uint32(b)) }

func (p *FPU_Periph) RMode() RMFPDSCR {
	return RMFPDSCR{mmio.UM32{&p.FPDSCR.U32, uint32(RMode)}}
}

func (p *FPU_Periph) FZ() RMFPDSCR {
	return RMFPDSCR{mmio.UM32{&p.FPDSCR.U32, uint32(FZ)}}
}

func (p *FPU_Periph) DN() RMFPDSCR {
	return RMFPDSCR{mmio.UM32{&p.FPDSCR.U32, uint32(DN)}}
}

func (p *FPU_Periph) AHP() RMFPDSCR {
	return RMFPDSCR{mmio.UM32{&p.FPDSCR.U32, uint32(AHP)}}
}
