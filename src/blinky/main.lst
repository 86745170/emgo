
main.elf:     file format elf32-littlearm


Disassembly of section .text:

08000000 <myvectors>:
 8000000:	00 00 02 20 89 00 00 08 99 00 00 08 a1 00 00 08     ... ............

08000010 <setupDataBSS>:
#include "types.h"

extern uint32 __dataStart, __dataEnd, __dataStartFlash;
extern uint32 __bssStart, __bssEnd;

void setupDataBSS() {
 8000010:	b480      	push	{r7}
 8000012:	b085      	sub	sp, #20
 8000014:	af00      	add	r7, sp, #0
	uint32 *src = &__dataStartFlash;
 8000016:	f240 5318 	movw	r3, #1304	; 0x518
 800001a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800001e:	60fb      	str	r3, [r7, #12]
	uint32 *dst = &__dataStart;
 8000020:	f240 0300 	movw	r3, #0
 8000024:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000028:	60bb      	str	r3, [r7, #8]
	uint32 *end = &__dataEnd;
 800002a:	f240 032c 	movw	r3, #44	; 0x2c
 800002e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000032:	607b      	str	r3, [r7, #4]

	while (dst < end) {
 8000034:	e009      	b.n	800004a <setupDataBSS+0x3a>
		*dst = *src;
 8000036:	68fb      	ldr	r3, [r7, #12]
 8000038:	681a      	ldr	r2, [r3, #0]
 800003a:	68bb      	ldr	r3, [r7, #8]
 800003c:	601a      	str	r2, [r3, #0]
		++dst;
 800003e:	68bb      	ldr	r3, [r7, #8]
 8000040:	3304      	adds	r3, #4
 8000042:	60bb      	str	r3, [r7, #8]
		++src;
 8000044:	68fb      	ldr	r3, [r7, #12]
 8000046:	3304      	adds	r3, #4
 8000048:	60fb      	str	r3, [r7, #12]
void setupDataBSS() {
	uint32 *src = &__dataStartFlash;
	uint32 *dst = &__dataStart;
	uint32 *end = &__dataEnd;

	while (dst < end) {
 800004a:	68ba      	ldr	r2, [r7, #8]
 800004c:	687b      	ldr	r3, [r7, #4]
 800004e:	429a      	cmp	r2, r3
 8000050:	d3f1      	bcc.n	8000036 <setupDataBSS+0x26>
		*dst = *src;
		++dst;
		++src;
	}

	dst = (uint32 *) & __bssStart;
 8000052:	f240 032c 	movw	r3, #44	; 0x2c
 8000056:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800005a:	60bb      	str	r3, [r7, #8]
	end = (uint32 *) & __bssEnd;
 800005c:	f240 032c 	movw	r3, #44	; 0x2c
 8000060:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000064:	607b      	str	r3, [r7, #4]

	while (dst < end) {
 8000066:	e005      	b.n	8000074 <setupDataBSS+0x64>
		*dst = 0;
 8000068:	68bb      	ldr	r3, [r7, #8]
 800006a:	2200      	movs	r2, #0
 800006c:	601a      	str	r2, [r3, #0]
		++dst;
 800006e:	68bb      	ldr	r3, [r7, #8]
 8000070:	3304      	adds	r3, #4
 8000072:	60bb      	str	r3, [r7, #8]
	}

	dst = (uint32 *) & __bssStart;
	end = (uint32 *) & __bssEnd;

	while (dst < end) {
 8000074:	68ba      	ldr	r2, [r7, #8]
 8000076:	687b      	ldr	r3, [r7, #4]
 8000078:	429a      	cmp	r2, r3
 800007a:	d3f5      	bcc.n	8000068 <setupDataBSS+0x58>
		*dst = 0;
		++dst;
	}
}
 800007c:	f107 0714 	add.w	r7, r7, #20
 8000080:	46bd      	mov	sp, r7
 8000082:	bc80      	pop	{r7}
 8000084:	4770      	bx	lr
 8000086:	bf00      	nop

08000088 <start>:

void main_main();

void start() {
 8000088:	b580      	push	{r7, lr}
 800008a:	af00      	add	r7, sp, #0
	setupDataBSS();
 800008c:	f7ff ffc0 	bl	8000010 <setupDataBSS>
	main_main();
 8000090:	f000 f80a 	bl	80000a8 <main_main>
}
 8000094:	bd80      	pop	{r7, pc}
 8000096:	bf00      	nop

08000098 <nmi_handler>:

void nmi_handler(void) {
 8000098:	b480      	push	{r7}
 800009a:	af00      	add	r7, sp, #0
	for (;;);
 800009c:	e7fe      	b.n	800009c <nmi_handler+0x4>
 800009e:	bf00      	nop

080000a0 <hardfault_handler>:
}

void hardfault_handler(void) {
 80000a0:	b480      	push	{r7}
 80000a2:	af00      	add	r7, sp, #0
	for (;;);
 80000a4:	e7fe      	b.n	80000a4 <hardfault_handler+0x4>
 80000a6:	bf00      	nop

080000a8 <main_main>:
	stm32_gpio_GPIO_ResetBit(stm32_gpio_D, 14);
	stm32_gpio_GPIO_ResetBit(stm32_gpio_D, 13);
	stm32_gpio_GPIO_SetBit(stm32_gpio_D, 12);
	delay_Loop(10000000);
}
void main_main() {
 80000a8:	b508      	push	{r3, lr}
static void main_loop();

// Implementation

void main_stm32f4init() {
	stm32_flash_SetLatency(5);
 80000aa:	2005      	movs	r0, #5
 80000ac:	f000 f9c6 	bl	800043c <stm32_flash_SetLatency>
	stm32_flash_SetPrefetch(true);
 80000b0:	2001      	movs	r0, #1
 80000b2:	f000 f987 	bl	80003c4 <stm32_flash_SetPrefetch>
	stm32_flash_SetICache(true);
 80000b6:	2001      	movs	r0, #1
 80000b8:	f000 f998 	bl	80003ec <stm32_flash_SetICache>
	stm32_flash_SetDCache(true);
 80000bc:	2001      	movs	r0, #1
 80000be:	f000 f9a9 	bl	8000414 <stm32_flash_SetDCache>
	while (stm32_flash_Latency()!=5) {
 80000c2:	f000 f9b3 	bl	800042c <stm32_flash_Latency>
 80000c6:	2805      	cmp	r0, #5
 80000c8:	d1fb      	bne.n	80000c2 <main_main+0x1a>
	}
	stm32_clock_ResetCR();
 80000ca:	f000 f895 	bl	80001f8 <stm32_clock_ResetCR>
	stm32_clock_ResetPLLCFGR();
 80000ce:	f000 f8f1 	bl	80002b4 <stm32_clock_ResetPLLCFGR>
	stm32_clock_ResetCFGR();
 80000d2:	f000 f933 	bl	800033c <stm32_clock_ResetCFGR>
	stm32_clock_ResetCIR();
 80000d6:	f000 f967 	bl	80003a8 <stm32_clock_ResetCIR>
	stm32_clock_EnableHSE();
 80000da:	f000 f8ab 	bl	8000234 <stm32_clock_EnableHSE>
	while (!stm32_clock_HSEReady()) {
 80000de:	f000 f8b9 	bl	8000254 <stm32_clock_HSEReady>
 80000e2:	2800      	cmp	r0, #0
 80000e4:	d0fb      	beq.n	80000de <main_main+0x36>
	}
	stm32_clock_SetPrescalerAHB(0);
 80000e6:	2000      	movs	r0, #0
 80000e8:	f000 f92e 	bl	8000348 <stm32_clock_SetPrescalerAHB>
	stm32_clock_SetPrescalerAPB1(5);
 80000ec:	2005      	movs	r0, #5
 80000ee:	f000 f935 	bl	800035c <stm32_clock_SetPrescalerAPB1>
	stm32_clock_SetPrescalerAPB2(4);
 80000f2:	2004      	movs	r0, #4
 80000f4:	f000 f93c 	bl	8000370 <stm32_clock_SetPrescalerAPB2>
	stm32_clock_SetPLLSrc(1);
 80000f8:	2001      	movs	r0, #1
 80000fa:	f000 f8e3 	bl	80002c4 <stm32_clock_SetPLLSrc>
	stm32_clock_SetPLLInputDiv(4);
 80000fe:	2004      	movs	r0, #4
 8000100:	f000 f8ea 	bl	80002d8 <stm32_clock_SetPLLInputDiv>
	stm32_clock_SetMainPLLMul(168);
 8000104:	20a8      	movs	r0, #168	; 0xa8
 8000106:	f000 f8f3 	bl	80002f0 <stm32_clock_SetMainPLLMul>
	stm32_clock_SetMainPLLSysDiv(2);
 800010a:	2002      	movs	r0, #2
 800010c:	f000 f8fe 	bl	800030c <stm32_clock_SetMainPLLSysDiv>
	stm32_clock_SetMainPLLPeriphDiv(7);
 8000110:	2007      	movs	r0, #7
 8000112:	f000 f907 	bl	8000324 <stm32_clock_SetMainPLLPeriphDiv>
	stm32_clock_EnableMainPLL();
 8000116:	f000 f8a5 	bl	8000264 <stm32_clock_EnableMainPLL>
	while (!stm32_clock_MainPLLReady()) {
 800011a:	f000 f8b3 	bl	8000284 <stm32_clock_MainPLLReady>
 800011e:	2800      	cmp	r0, #0
 8000120:	d0fb      	beq.n	800011a <main_main+0x72>
	}
	stm32_clock_SetSysClock(2);
 8000122:	2002      	movs	r0, #2
 8000124:	f000 f936 	bl	8000394 <stm32_clock_SetSysClock>
	while (stm32_clock_SysClock()!=2) {
 8000128:	f000 f92c 	bl	8000384 <stm32_clock_SysClock>
 800012c:	2802      	cmp	r0, #2
 800012e:	d1fb      	bne.n	8000128 <main_main+0x80>
	}
}
void main_setupLEDpins() {
	stm32_periph_AHB1ClockEnable(8);
	stm32_periph_AHB1Reset(8);
	stm32_gpio_GPIO_SetMode(stm32_gpio_D, 12, 1);
 8000130:	4c2b      	ldr	r4, [pc, #172]	; (80001e0 <main_main+0x138>)
	stm32_clock_SetSysClock(2);
	while (stm32_clock_SysClock()!=2) {
	}
}
void main_setupLEDpins() {
	stm32_periph_AHB1ClockEnable(8);
 8000132:	2008      	movs	r0, #8
 8000134:	f000 f9d4 	bl	80004e0 <stm32_periph_AHB1ClockEnable>
	stm32_periph_AHB1Reset(8);
 8000138:	2008      	movs	r0, #8
 800013a:	f000 f9e1 	bl	8000500 <stm32_periph_AHB1Reset>
	stm32_gpio_GPIO_SetMode(stm32_gpio_D, 12, 1);
 800013e:	6820      	ldr	r0, [r4, #0]
 8000140:	210c      	movs	r1, #12
 8000142:	2201      	movs	r2, #1
 8000144:	f000 f98d 	bl	8000462 <stm32_gpio_GPIO_SetMode>
	stm32_gpio_GPIO_SetMode(stm32_gpio_D, 13, 1);
 8000148:	6820      	ldr	r0, [r4, #0]
 800014a:	210d      	movs	r1, #13
 800014c:	2201      	movs	r2, #1
 800014e:	f000 f988 	bl	8000462 <stm32_gpio_GPIO_SetMode>
	stm32_gpio_GPIO_SetMode(stm32_gpio_D, 14, 1);
 8000152:	6820      	ldr	r0, [r4, #0]
 8000154:	210e      	movs	r1, #14
 8000156:	2201      	movs	r2, #1
 8000158:	f000 f983 	bl	8000462 <stm32_gpio_GPIO_SetMode>
	stm32_gpio_GPIO_SetMode(stm32_gpio_D, 15, 1);
 800015c:	6820      	ldr	r0, [r4, #0]
 800015e:	210f      	movs	r1, #15
 8000160:	2201      	movs	r2, #1
 8000162:	f000 f97e 	bl	8000462 <stm32_gpio_GPIO_SetMode>
}
void main_loop() {
	stm32_gpio_GPIO_ResetBit(stm32_gpio_D, 12);
 8000166:	6820      	ldr	r0, [r4, #0]
 8000168:	210c      	movs	r1, #12
 800016a:	f000 f9ab 	bl	80004c4 <stm32_gpio_GPIO_ResetBit>
	stm32_gpio_GPIO_SetBit(stm32_gpio_D, 13);
 800016e:	6820      	ldr	r0, [r4, #0]
 8000170:	210d      	movs	r1, #13
 8000172:	f000 f9a2 	bl	80004ba <stm32_gpio_GPIO_SetBit>
	stm32_gpio_GPIO_SetBit(stm32_gpio_D, 14);
 8000176:	6820      	ldr	r0, [r4, #0]
 8000178:	210e      	movs	r1, #14
 800017a:	f000 f99e 	bl	80004ba <stm32_gpio_GPIO_SetBit>
	delay_Loop(1000000);
 800017e:	4819      	ldr	r0, [pc, #100]	; (80001e4 <main_main+0x13c>)
 8000180:	f000 f834 	bl	80001ec <delay_Loop>
	stm32_gpio_GPIO_ResetBit(stm32_gpio_D, 14);
 8000184:	6820      	ldr	r0, [r4, #0]
 8000186:	210e      	movs	r1, #14
 8000188:	f000 f99c 	bl	80004c4 <stm32_gpio_GPIO_ResetBit>
	stm32_gpio_GPIO_ResetBit(stm32_gpio_D, 13);
 800018c:	6820      	ldr	r0, [r4, #0]
 800018e:	210d      	movs	r1, #13
 8000190:	f000 f998 	bl	80004c4 <stm32_gpio_GPIO_ResetBit>
	stm32_gpio_GPIO_SetBit(stm32_gpio_D, 15);
 8000194:	6820      	ldr	r0, [r4, #0]
 8000196:	210f      	movs	r1, #15
 8000198:	f000 f98f 	bl	80004ba <stm32_gpio_GPIO_SetBit>
	delay_Loop(1000000);
 800019c:	4811      	ldr	r0, [pc, #68]	; (80001e4 <main_main+0x13c>)
 800019e:	f000 f825 	bl	80001ec <delay_Loop>
	stm32_gpio_GPIO_ResetBit(stm32_gpio_D, 15);
 80001a2:	6820      	ldr	r0, [r4, #0]
 80001a4:	210f      	movs	r1, #15
 80001a6:	f000 f98d 	bl	80004c4 <stm32_gpio_GPIO_ResetBit>
	stm32_gpio_GPIO_SetBit(stm32_gpio_D, 13);
 80001aa:	6820      	ldr	r0, [r4, #0]
 80001ac:	210d      	movs	r1, #13
 80001ae:	f000 f984 	bl	80004ba <stm32_gpio_GPIO_SetBit>
	stm32_gpio_GPIO_SetBit(stm32_gpio_D, 14);
 80001b2:	6820      	ldr	r0, [r4, #0]
 80001b4:	210e      	movs	r1, #14
 80001b6:	f000 f980 	bl	80004ba <stm32_gpio_GPIO_SetBit>
	delay_Loop(1000000);
 80001ba:	480a      	ldr	r0, [pc, #40]	; (80001e4 <main_main+0x13c>)
 80001bc:	f000 f816 	bl	80001ec <delay_Loop>
	stm32_gpio_GPIO_ResetBit(stm32_gpio_D, 14);
 80001c0:	6820      	ldr	r0, [r4, #0]
 80001c2:	210e      	movs	r1, #14
 80001c4:	f000 f97e 	bl	80004c4 <stm32_gpio_GPIO_ResetBit>
	stm32_gpio_GPIO_ResetBit(stm32_gpio_D, 13);
 80001c8:	6820      	ldr	r0, [r4, #0]
 80001ca:	210d      	movs	r1, #13
 80001cc:	f000 f97a 	bl	80004c4 <stm32_gpio_GPIO_ResetBit>
	stm32_gpio_GPIO_SetBit(stm32_gpio_D, 12);
 80001d0:	6820      	ldr	r0, [r4, #0]
 80001d2:	210c      	movs	r1, #12
 80001d4:	f000 f971 	bl	80004ba <stm32_gpio_GPIO_SetBit>
	delay_Loop(10000000);
 80001d8:	4803      	ldr	r0, [pc, #12]	; (80001e8 <main_main+0x140>)
 80001da:	f000 f807 	bl	80001ec <delay_Loop>
 80001de:	e7c2      	b.n	8000166 <main_main+0xbe>
 80001e0:	2000001c 	.word	0x2000001c
 80001e4:	000f4240 	.word	0x000f4240
 80001e8:	00989680 	.word	0x00989680

080001ec <delay_Loop>:
void delay_Loop(int i) {
	while (i > 0) {
 80001ec:	e001      	b.n	80001f2 <delay_Loop+0x6>
		asm volatile ("nop");
 80001ee:	bf00      	nop
		--i;
 80001f0:	3801      	subs	r0, #1
void delay_Loop(int i) {
	while (i > 0) {
 80001f2:	2800      	cmp	r0, #0
 80001f4:	dcfb      	bgt.n	80001ee <delay_Loop+0x2>
		asm volatile ("nop");
		--i;
	}
}
 80001f6:	4770      	bx	lr

080001f8 <stm32_clock_ResetCR>:

// Implementation

static stm32_clock_regs* stm32_clock_c = (stm32_clock_regs*)((unsafe_Pointer)(1073887232));
void stm32_clock_ResetCR() {
	stm32_clock_c->cr = 131;
 80001f8:	4b01      	ldr	r3, [pc, #4]	; (8000200 <stm32_clock_ResetCR+0x8>)
 80001fa:	2283      	movs	r2, #131	; 0x83
 80001fc:	601a      	str	r2, [r3, #0]
 80001fe:	4770      	bx	lr
 8000200:	40023800 	.word	0x40023800

08000204 <stm32_clock_EnableHSI>:
}
void stm32_clock_EnableHSI() {
	stm32_clock_c->cr |= 1;
 8000204:	4b02      	ldr	r3, [pc, #8]	; (8000210 <stm32_clock_EnableHSI+0xc>)
 8000206:	681a      	ldr	r2, [r3, #0]
 8000208:	f042 0201 	orr.w	r2, r2, #1
 800020c:	601a      	str	r2, [r3, #0]
 800020e:	4770      	bx	lr
 8000210:	40023800 	.word	0x40023800

08000214 <stm32_clock_DisableHSI>:
}
void stm32_clock_DisableHSI() {
	stm32_clock_c->cr &= ~(1);
 8000214:	4b02      	ldr	r3, [pc, #8]	; (8000220 <stm32_clock_DisableHSI+0xc>)
 8000216:	681a      	ldr	r2, [r3, #0]
 8000218:	f022 0201 	bic.w	r2, r2, #1
 800021c:	601a      	str	r2, [r3, #0]
 800021e:	4770      	bx	lr
 8000220:	40023800 	.word	0x40023800

08000224 <stm32_clock_HSIReady>:
}
bool stm32_clock_HSIReady() {
	return stm32_clock_c->cr&2!=0;
 8000224:	4b02      	ldr	r3, [pc, #8]	; (8000230 <stm32_clock_HSIReady+0xc>)
 8000226:	6818      	ldr	r0, [r3, #0]
}
 8000228:	f000 0001 	and.w	r0, r0, #1
 800022c:	4770      	bx	lr
 800022e:	bf00      	nop
 8000230:	40023800 	.word	0x40023800

08000234 <stm32_clock_EnableHSE>:
void stm32_clock_EnableHSE() {
	stm32_clock_c->cr |= 65536;
 8000234:	4b02      	ldr	r3, [pc, #8]	; (8000240 <stm32_clock_EnableHSE+0xc>)
 8000236:	681a      	ldr	r2, [r3, #0]
 8000238:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800023c:	601a      	str	r2, [r3, #0]
 800023e:	4770      	bx	lr
 8000240:	40023800 	.word	0x40023800

08000244 <stm32_clock_DisableHSE>:
}
void stm32_clock_DisableHSE() {
	stm32_clock_c->cr &= ~(65536);
 8000244:	4b02      	ldr	r3, [pc, #8]	; (8000250 <stm32_clock_DisableHSE+0xc>)
 8000246:	681a      	ldr	r2, [r3, #0]
 8000248:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800024c:	601a      	str	r2, [r3, #0]
 800024e:	4770      	bx	lr
 8000250:	40023800 	.word	0x40023800

08000254 <stm32_clock_HSEReady>:
}
bool stm32_clock_HSEReady() {
	return stm32_clock_c->cr&131072!=0;
 8000254:	4b02      	ldr	r3, [pc, #8]	; (8000260 <stm32_clock_HSEReady+0xc>)
 8000256:	6818      	ldr	r0, [r3, #0]
}
 8000258:	f000 0001 	and.w	r0, r0, #1
 800025c:	4770      	bx	lr
 800025e:	bf00      	nop
 8000260:	40023800 	.word	0x40023800

08000264 <stm32_clock_EnableMainPLL>:
void stm32_clock_EnableMainPLL() {
	stm32_clock_c->cr |= 16777216;
 8000264:	4b02      	ldr	r3, [pc, #8]	; (8000270 <stm32_clock_EnableMainPLL+0xc>)
 8000266:	681a      	ldr	r2, [r3, #0]
 8000268:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800026c:	601a      	str	r2, [r3, #0]
 800026e:	4770      	bx	lr
 8000270:	40023800 	.word	0x40023800

08000274 <stm32_clock_DisableMainPLL>:
}
void stm32_clock_DisableMainPLL() {
	stm32_clock_c->cr &= ~(16777216);
 8000274:	4b02      	ldr	r3, [pc, #8]	; (8000280 <stm32_clock_DisableMainPLL+0xc>)
 8000276:	681a      	ldr	r2, [r3, #0]
 8000278:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 800027c:	601a      	str	r2, [r3, #0]
 800027e:	4770      	bx	lr
 8000280:	40023800 	.word	0x40023800

08000284 <stm32_clock_MainPLLReady>:
}
bool stm32_clock_MainPLLReady() {
	return stm32_clock_c->cr&33554432!=0;
 8000284:	4b02      	ldr	r3, [pc, #8]	; (8000290 <stm32_clock_MainPLLReady+0xc>)
 8000286:	6818      	ldr	r0, [r3, #0]
}
 8000288:	f000 0001 	and.w	r0, r0, #1
 800028c:	4770      	bx	lr
 800028e:	bf00      	nop
 8000290:	40023800 	.word	0x40023800

08000294 <stm32_clock_EnableSecurity>:
void stm32_clock_EnableSecurity() {
	stm32_clock_c->cr |= 524288;
 8000294:	4b02      	ldr	r3, [pc, #8]	; (80002a0 <stm32_clock_EnableSecurity+0xc>)
 8000296:	681a      	ldr	r2, [r3, #0]
 8000298:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 800029c:	601a      	str	r2, [r3, #0]
 800029e:	4770      	bx	lr
 80002a0:	40023800 	.word	0x40023800

080002a4 <stm32_clock_DisableSecurity>:
}
void stm32_clock_DisableSecurity() {
	stm32_clock_c->cr &= ~(524288);
 80002a4:	4b02      	ldr	r3, [pc, #8]	; (80002b0 <stm32_clock_DisableSecurity+0xc>)
 80002a6:	681a      	ldr	r2, [r3, #0]
 80002a8:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 80002ac:	601a      	str	r2, [r3, #0]
 80002ae:	4770      	bx	lr
 80002b0:	40023800 	.word	0x40023800

080002b4 <stm32_clock_ResetPLLCFGR>:
}
void stm32_clock_ResetPLLCFGR() {
	stm32_clock_c->pllcfgr = 603992080;
 80002b4:	4a01      	ldr	r2, [pc, #4]	; (80002bc <stm32_clock_ResetPLLCFGR+0x8>)
 80002b6:	4b02      	ldr	r3, [pc, #8]	; (80002c0 <stm32_clock_ResetPLLCFGR+0xc>)
 80002b8:	605a      	str	r2, [r3, #4]
 80002ba:	4770      	bx	lr
 80002bc:	24003010 	.word	0x24003010
 80002c0:	40023800 	.word	0x40023800

080002c4 <stm32_clock_SetPLLSrc>:
}
void stm32_clock_SetPLLSrc(stm32_clock_PLLSrc src) {
	stm32_clock_c->pllcfgr = stm32_clock_c->pllcfgr&~4194304|(uint32)(src)<<22;
 80002c4:	4b03      	ldr	r3, [pc, #12]	; (80002d4 <stm32_clock_SetPLLSrc+0x10>)
 80002c6:	685a      	ldr	r2, [r3, #4]
 80002c8:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
 80002cc:	ea42 5080 	orr.w	r0, r2, r0, lsl #22
 80002d0:	6058      	str	r0, [r3, #4]
 80002d2:	4770      	bx	lr
 80002d4:	40023800 	.word	0x40023800

080002d8 <stm32_clock_SetPLLInputDiv>:
}
void stm32_clock_SetPLLInputDiv(int div) {
	stm32_clock_c->pllcfgr = stm32_clock_c->pllcfgr&~63|(uint32)(div&63);
 80002d8:	4b04      	ldr	r3, [pc, #16]	; (80002ec <stm32_clock_SetPLLInputDiv+0x14>)
 80002da:	685a      	ldr	r2, [r3, #4]
 80002dc:	f000 003f 	and.w	r0, r0, #63	; 0x3f
 80002e0:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 80002e4:	4302      	orrs	r2, r0
 80002e6:	605a      	str	r2, [r3, #4]
 80002e8:	4770      	bx	lr
 80002ea:	bf00      	nop
 80002ec:	40023800 	.word	0x40023800

080002f0 <stm32_clock_SetMainPLLMul>:
}
void stm32_clock_SetMainPLLMul(int mul) {
	stm32_clock_c->pllcfgr = stm32_clock_c->pllcfgr&~32704|(uint32)(mul&511)<<6;
 80002f0:	4b05      	ldr	r3, [pc, #20]	; (8000308 <stm32_clock_SetMainPLLMul+0x18>)
 80002f2:	685a      	ldr	r2, [r3, #4]
 80002f4:	f422 42ff 	bic.w	r2, r2, #32640	; 0x7f80
 80002f8:	f3c0 0008 	ubfx	r0, r0, #0, #9
 80002fc:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8000300:	ea42 1080 	orr.w	r0, r2, r0, lsl #6
 8000304:	6058      	str	r0, [r3, #4]
 8000306:	4770      	bx	lr
 8000308:	40023800 	.word	0x40023800

0800030c <stm32_clock_SetMainPLLSysDiv>:
}
void stm32_clock_SetMainPLLSysDiv(int div) {
	div = (div>>1)-1;
	stm32_clock_c->pllcfgr = stm32_clock_c->pllcfgr&~196608|(uint32)(div)<<16;
 800030c:	4b04      	ldr	r3, [pc, #16]	; (8000320 <stm32_clock_SetMainPLLSysDiv+0x14>)
 800030e:	6859      	ldr	r1, [r3, #4]
}
void stm32_clock_SetMainPLLMul(int mul) {
	stm32_clock_c->pllcfgr = stm32_clock_c->pllcfgr&~32704|(uint32)(mul&511)<<6;
}
void stm32_clock_SetMainPLLSysDiv(int div) {
	div = (div>>1)-1;
 8000310:	1040      	asrs	r0, r0, #1
 8000312:	1e42      	subs	r2, r0, #1
	stm32_clock_c->pllcfgr = stm32_clock_c->pllcfgr&~196608|(uint32)(div)<<16;
 8000314:	f421 3140 	bic.w	r1, r1, #196608	; 0x30000
 8000318:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
 800031c:	605a      	str	r2, [r3, #4]
 800031e:	4770      	bx	lr
 8000320:	40023800 	.word	0x40023800

08000324 <stm32_clock_SetMainPLLPeriphDiv>:
}
void stm32_clock_SetMainPLLPeriphDiv(int div) {
	stm32_clock_c->pllcfgr = stm32_clock_c->pllcfgr&~251658240|(uint32)(div&15)<<24;
 8000324:	4b04      	ldr	r3, [pc, #16]	; (8000338 <stm32_clock_SetMainPLLPeriphDiv+0x14>)
 8000326:	685a      	ldr	r2, [r3, #4]
 8000328:	f000 000f 	and.w	r0, r0, #15
 800032c:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8000330:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8000334:	605a      	str	r2, [r3, #4]
 8000336:	4770      	bx	lr
 8000338:	40023800 	.word	0x40023800

0800033c <stm32_clock_ResetCFGR>:
}
void stm32_clock_ResetCFGR() {
	stm32_clock_c->cfgr = 0;
 800033c:	4b01      	ldr	r3, [pc, #4]	; (8000344 <stm32_clock_ResetCFGR+0x8>)
 800033e:	2200      	movs	r2, #0
 8000340:	609a      	str	r2, [r3, #8]
 8000342:	4770      	bx	lr
 8000344:	40023800 	.word	0x40023800

08000348 <stm32_clock_SetPrescalerAHB>:
}
void stm32_clock_SetPrescalerAHB(stm32_clock_AHBDiv div) {
	stm32_clock_c->cfgr = stm32_clock_c->cfgr&~240|(uint32)(div);
 8000348:	4b03      	ldr	r3, [pc, #12]	; (8000358 <stm32_clock_SetPrescalerAHB+0x10>)
 800034a:	689a      	ldr	r2, [r3, #8]
 800034c:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8000350:	4310      	orrs	r0, r2
 8000352:	6098      	str	r0, [r3, #8]
 8000354:	4770      	bx	lr
 8000356:	bf00      	nop
 8000358:	40023800 	.word	0x40023800

0800035c <stm32_clock_SetPrescalerAPB1>:
}
void stm32_clock_SetPrescalerAPB1(stm32_clock_APBDiv div) {
	stm32_clock_c->cfgr = stm32_clock_c->cfgr&~7168|(uint32)(div)<<10;
 800035c:	4b03      	ldr	r3, [pc, #12]	; (800036c <stm32_clock_SetPrescalerAPB1+0x10>)
 800035e:	689a      	ldr	r2, [r3, #8]
 8000360:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
 8000364:	ea42 2080 	orr.w	r0, r2, r0, lsl #10
 8000368:	6098      	str	r0, [r3, #8]
 800036a:	4770      	bx	lr
 800036c:	40023800 	.word	0x40023800

08000370 <stm32_clock_SetPrescalerAPB2>:
}
void stm32_clock_SetPrescalerAPB2(stm32_clock_APBDiv div) {
	stm32_clock_c->cfgr = stm32_clock_c->cfgr&~57344|(uint32)(div)<<13;
 8000370:	4b03      	ldr	r3, [pc, #12]	; (8000380 <stm32_clock_SetPrescalerAPB2+0x10>)
 8000372:	689a      	ldr	r2, [r3, #8]
 8000374:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8000378:	ea42 3040 	orr.w	r0, r2, r0, lsl #13
 800037c:	6098      	str	r0, [r3, #8]
 800037e:	4770      	bx	lr
 8000380:	40023800 	.word	0x40023800

08000384 <stm32_clock_SysClock>:
}
stm32_clock_Clock stm32_clock_SysClock() {
	return (stm32_clock_Clock)((stm32_clock_c->cfgr>>2)&3);
 8000384:	4b02      	ldr	r3, [pc, #8]	; (8000390 <stm32_clock_SysClock+0xc>)
 8000386:	6898      	ldr	r0, [r3, #8]
}
 8000388:	f3c0 0081 	ubfx	r0, r0, #2, #2
 800038c:	4770      	bx	lr
 800038e:	bf00      	nop
 8000390:	40023800 	.word	0x40023800

08000394 <stm32_clock_SetSysClock>:
void stm32_clock_SetSysClock(stm32_clock_Clock src) {
	stm32_clock_c->cfgr = stm32_clock_c->cfgr&~3|(uint32)(src);
 8000394:	4b03      	ldr	r3, [pc, #12]	; (80003a4 <stm32_clock_SetSysClock+0x10>)
 8000396:	689a      	ldr	r2, [r3, #8]
 8000398:	f022 0203 	bic.w	r2, r2, #3
 800039c:	4310      	orrs	r0, r2
 800039e:	6098      	str	r0, [r3, #8]
 80003a0:	4770      	bx	lr
 80003a2:	bf00      	nop
 80003a4:	40023800 	.word	0x40023800

080003a8 <stm32_clock_ResetCIR>:
}
void stm32_clock_ResetCIR() {
	stm32_clock_c->cir = 0;
 80003a8:	4b01      	ldr	r3, [pc, #4]	; (80003b0 <stm32_clock_ResetCIR+0x8>)
 80003aa:	2200      	movs	r2, #0
 80003ac:	60da      	str	r2, [r3, #12]
 80003ae:	4770      	bx	lr
 80003b0:	40023800 	.word	0x40023800

080003b4 <stm32_flash_Prefetch>:
		r->acr &= ~(1<<n);
	}
}
static stm32_flash_regs* stm32_flash_f = (stm32_flash_regs*)((unsafe_Pointer)(1073888256));
bool stm32_flash_Prefetch() {
	return stm32_flash_f->acr&256!=0;
 80003b4:	4b02      	ldr	r3, [pc, #8]	; (80003c0 <stm32_flash_Prefetch+0xc>)
 80003b6:	6818      	ldr	r0, [r3, #0]
}
 80003b8:	f000 0001 	and.w	r0, r0, #1
 80003bc:	4770      	bx	lr
 80003be:	bf00      	nop
 80003c0:	40023c00 	.word	0x40023c00

080003c4 <stm32_flash_SetPrefetch>:
void stm32_flash_SetPrefetch(bool enable) {
 80003c4:	4b04      	ldr	r3, [pc, #16]	; (80003d8 <stm32_flash_SetPrefetch+0x14>)

// Implementation

void stm32_flash_regs_acrSetBit(stm32_flash_regs* r, uint n, bool b) {
	if (b) {
		r->acr |= 1<<n;
 80003c6:	681a      	ldr	r2, [r3, #0]
static stm32_flash_regs* stm32_flash_f;

// Implementation

void stm32_flash_regs_acrSetBit(stm32_flash_regs* r, uint n, bool b) {
	if (b) {
 80003c8:	b110      	cbz	r0, 80003d0 <stm32_flash_SetPrefetch+0xc>
		r->acr |= 1<<n;
 80003ca:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80003ce:	e001      	b.n	80003d4 <stm32_flash_SetPrefetch+0x10>
	} else {
		r->acr &= ~(1<<n);
 80003d0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80003d4:	601a      	str	r2, [r3, #0]
 80003d6:	4770      	bx	lr
 80003d8:	40023c00 	.word	0x40023c00

080003dc <stm32_flash_ICache>:
}
void stm32_flash_SetPrefetch(bool enable) {
	stm32_flash_regs_acrSetBit(stm32_flash_f, 8, enable);
}
bool stm32_flash_ICache() {
	return stm32_flash_f->acr&512!=0;
 80003dc:	4b02      	ldr	r3, [pc, #8]	; (80003e8 <stm32_flash_ICache+0xc>)
 80003de:	6818      	ldr	r0, [r3, #0]
}
 80003e0:	f000 0001 	and.w	r0, r0, #1
 80003e4:	4770      	bx	lr
 80003e6:	bf00      	nop
 80003e8:	40023c00 	.word	0x40023c00

080003ec <stm32_flash_SetICache>:
void stm32_flash_SetICache(bool enable) {
 80003ec:	4b04      	ldr	r3, [pc, #16]	; (8000400 <stm32_flash_SetICache+0x14>)

// Implementation

void stm32_flash_regs_acrSetBit(stm32_flash_regs* r, uint n, bool b) {
	if (b) {
		r->acr |= 1<<n;
 80003ee:	681a      	ldr	r2, [r3, #0]
static stm32_flash_regs* stm32_flash_f;

// Implementation

void stm32_flash_regs_acrSetBit(stm32_flash_regs* r, uint n, bool b) {
	if (b) {
 80003f0:	b110      	cbz	r0, 80003f8 <stm32_flash_SetICache+0xc>
		r->acr |= 1<<n;
 80003f2:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80003f6:	e001      	b.n	80003fc <stm32_flash_SetICache+0x10>
	} else {
		r->acr &= ~(1<<n);
 80003f8:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 80003fc:	601a      	str	r2, [r3, #0]
 80003fe:	4770      	bx	lr
 8000400:	40023c00 	.word	0x40023c00

08000404 <stm32_flash_DCache>:
}
void stm32_flash_SetICache(bool enable) {
	stm32_flash_regs_acrSetBit(stm32_flash_f, 9, enable);
}
bool stm32_flash_DCache() {
	return stm32_flash_f->acr&1024!=0;
 8000404:	4b02      	ldr	r3, [pc, #8]	; (8000410 <stm32_flash_DCache+0xc>)
 8000406:	6818      	ldr	r0, [r3, #0]
}
 8000408:	f000 0001 	and.w	r0, r0, #1
 800040c:	4770      	bx	lr
 800040e:	bf00      	nop
 8000410:	40023c00 	.word	0x40023c00

08000414 <stm32_flash_SetDCache>:
void stm32_flash_SetDCache(bool enable) {
 8000414:	4b04      	ldr	r3, [pc, #16]	; (8000428 <stm32_flash_SetDCache+0x14>)

// Implementation

void stm32_flash_regs_acrSetBit(stm32_flash_regs* r, uint n, bool b) {
	if (b) {
		r->acr |= 1<<n;
 8000416:	681a      	ldr	r2, [r3, #0]
static stm32_flash_regs* stm32_flash_f;

// Implementation

void stm32_flash_regs_acrSetBit(stm32_flash_regs* r, uint n, bool b) {
	if (b) {
 8000418:	b110      	cbz	r0, 8000420 <stm32_flash_SetDCache+0xc>
		r->acr |= 1<<n;
 800041a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800041e:	e001      	b.n	8000424 <stm32_flash_SetDCache+0x10>
	} else {
		r->acr &= ~(1<<n);
 8000420:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000424:	601a      	str	r2, [r3, #0]
 8000426:	4770      	bx	lr
 8000428:	40023c00 	.word	0x40023c00

0800042c <stm32_flash_Latency>:
}
void stm32_flash_SetDCache(bool enable) {
	stm32_flash_regs_acrSetBit(stm32_flash_f, 10, enable);
}
int stm32_flash_Latency() {
	return (int)(stm32_flash_f->acr&7);
 800042c:	4b02      	ldr	r3, [pc, #8]	; (8000438 <stm32_flash_Latency+0xc>)
 800042e:	6818      	ldr	r0, [r3, #0]
}
 8000430:	f000 0007 	and.w	r0, r0, #7
 8000434:	4770      	bx	lr
 8000436:	bf00      	nop
 8000438:	40023c00 	.word	0x40023c00

0800043c <stm32_flash_SetLatency>:
void stm32_flash_SetLatency(int waitStates) {
	stm32_flash_f->acr = stm32_flash_f->acr&~7|(uint32)(waitStates)&7;
 800043c:	4b04      	ldr	r3, [pc, #16]	; (8000450 <stm32_flash_SetLatency+0x14>)
 800043e:	681a      	ldr	r2, [r3, #0]
 8000440:	f000 0007 	and.w	r0, r0, #7
 8000444:	f022 0207 	bic.w	r2, r2, #7
 8000448:	4302      	orrs	r2, r0
 800044a:	601a      	str	r2, [r3, #0]
 800044c:	4770      	bx	lr
 800044e:	bf00      	nop
 8000450:	40023c00 	.word	0x40023c00

08000454 <stm32_gpio_GPIO_Mode>:
stm32_gpio_GPIO* stm32_gpio_I = (stm32_gpio_GPIO*)((unsafe_Pointer)(1073881088));
stm32_gpio_GPIO* stm32_gpio_J = (stm32_gpio_GPIO*)((unsafe_Pointer)(1073882112));
stm32_gpio_GPIO* stm32_gpio_K = (stm32_gpio_GPIO*)((unsafe_Pointer)(1073883136));
stm32_gpio_Mode stm32_gpio_GPIO_Mode(stm32_gpio_GPIO* g, int n) {
	n *= 2;
	return (stm32_gpio_Mode)(g->moder>>(uint)(n))&3;
 8000454:	6803      	ldr	r3, [r0, #0]
stm32_gpio_GPIO* stm32_gpio_H = (stm32_gpio_GPIO*)((unsafe_Pointer)(1073880064));
stm32_gpio_GPIO* stm32_gpio_I = (stm32_gpio_GPIO*)((unsafe_Pointer)(1073881088));
stm32_gpio_GPIO* stm32_gpio_J = (stm32_gpio_GPIO*)((unsafe_Pointer)(1073882112));
stm32_gpio_GPIO* stm32_gpio_K = (stm32_gpio_GPIO*)((unsafe_Pointer)(1073883136));
stm32_gpio_Mode stm32_gpio_GPIO_Mode(stm32_gpio_GPIO* g, int n) {
	n *= 2;
 8000456:	0049      	lsls	r1, r1, #1
	return (stm32_gpio_Mode)(g->moder>>(uint)(n))&3;
 8000458:	fa23 f001 	lsr.w	r0, r3, r1
}
 800045c:	f000 0003 	and.w	r0, r0, #3
 8000460:	4770      	bx	lr

08000462 <stm32_gpio_GPIO_SetMode>:
void stm32_gpio_GPIO_SetMode(stm32_gpio_GPIO* g, int n, stm32_gpio_Mode mode) {
	n *= 2;
 8000462:	0049      	lsls	r1, r1, #1
stm32_gpio_GPIO* stm32_gpio_K = (stm32_gpio_GPIO*)((unsafe_Pointer)(1073883136));
stm32_gpio_Mode stm32_gpio_GPIO_Mode(stm32_gpio_GPIO* g, int n) {
	n *= 2;
	return (stm32_gpio_Mode)(g->moder>>(uint)(n))&3;
}
void stm32_gpio_GPIO_SetMode(stm32_gpio_GPIO* g, int n, stm32_gpio_Mode mode) {
 8000464:	b510      	push	{r4, lr}
	n *= 2;
	g->moder = g->moder&~(3<<(uint)(n))|(uint32)(mode)<<(uint)(n);
 8000466:	2303      	movs	r3, #3
 8000468:	6804      	ldr	r4, [r0, #0]
 800046a:	408b      	lsls	r3, r1
 800046c:	ea24 0303 	bic.w	r3, r4, r3
 8000470:	408a      	lsls	r2, r1
 8000472:	4313      	orrs	r3, r2
 8000474:	6003      	str	r3, [r0, #0]
 8000476:	bd10      	pop	{r4, pc}

08000478 <stm32_gpio_GPIO_OutType>:
}
stm32_gpio_OutType stm32_gpio_GPIO_OutType(stm32_gpio_GPIO* g, int n) {
	return (stm32_gpio_OutType)(g->otyper>>(uint)(n))&1;
 8000478:	6840      	ldr	r0, [r0, #4]
 800047a:	40c8      	lsrs	r0, r1
}
 800047c:	f000 0001 	and.w	r0, r0, #1
 8000480:	4770      	bx	lr

08000482 <stm32_gpio_GPIO_SetOutType>:
void stm32_gpio_GPIO_SetOutType(stm32_gpio_GPIO* g, int n, stm32_gpio_OutType ot) {
 8000482:	b510      	push	{r4, lr}
	g->otyper = g->otyper&~(1<<(uint)(n))|(uint32)(ot)<<(uint)(n);
 8000484:	2301      	movs	r3, #1
 8000486:	6844      	ldr	r4, [r0, #4]
 8000488:	408b      	lsls	r3, r1
 800048a:	ea24 0303 	bic.w	r3, r4, r3
 800048e:	408a      	lsls	r2, r1
 8000490:	4313      	orrs	r3, r2
 8000492:	6043      	str	r3, [r0, #4]
 8000494:	bd10      	pop	{r4, pc}

08000496 <stm32_gpio_GPIO_OutSpeed>:
}
stm32_gpio_Speed stm32_gpio_GPIO_OutSpeed(stm32_gpio_GPIO* g, int n) {
	n *= 2;
	return (stm32_gpio_Speed)(g->ospeedr>>(uint)(n))&3;
 8000496:	6883      	ldr	r3, [r0, #8]
}
void stm32_gpio_GPIO_SetOutType(stm32_gpio_GPIO* g, int n, stm32_gpio_OutType ot) {
	g->otyper = g->otyper&~(1<<(uint)(n))|(uint32)(ot)<<(uint)(n);
}
stm32_gpio_Speed stm32_gpio_GPIO_OutSpeed(stm32_gpio_GPIO* g, int n) {
	n *= 2;
 8000498:	0049      	lsls	r1, r1, #1
	return (stm32_gpio_Speed)(g->ospeedr>>(uint)(n))&3;
 800049a:	fa23 f001 	lsr.w	r0, r3, r1
}
 800049e:	f000 0003 	and.w	r0, r0, #3
 80004a2:	4770      	bx	lr

080004a4 <stm32_gpio_GPIO_SetOutSpeed>:
void stm32_gpio_GPIO_SetOutSpeed(stm32_gpio_GPIO* g, int n, stm32_gpio_Speed speed) {
	n *= 2;
 80004a4:	0049      	lsls	r1, r1, #1
}
stm32_gpio_Speed stm32_gpio_GPIO_OutSpeed(stm32_gpio_GPIO* g, int n) {
	n *= 2;
	return (stm32_gpio_Speed)(g->ospeedr>>(uint)(n))&3;
}
void stm32_gpio_GPIO_SetOutSpeed(stm32_gpio_GPIO* g, int n, stm32_gpio_Speed speed) {
 80004a6:	b510      	push	{r4, lr}
	n *= 2;
	g->ospeedr = g->ospeedr&~(3<<(uint)(n))|(uint32)(speed)<<(uint)(n);
 80004a8:	2303      	movs	r3, #3
 80004aa:	6884      	ldr	r4, [r0, #8]
 80004ac:	408b      	lsls	r3, r1
 80004ae:	ea24 0303 	bic.w	r3, r4, r3
 80004b2:	408a      	lsls	r2, r1
 80004b4:	4313      	orrs	r3, r2
 80004b6:	6083      	str	r3, [r0, #8]
 80004b8:	bd10      	pop	{r4, pc}

080004ba <stm32_gpio_GPIO_SetBit>:
}
void stm32_gpio_GPIO_SetBit(stm32_gpio_GPIO* g, int n) {
	g->bsrr = 1<<(uint)(n);
 80004ba:	2301      	movs	r3, #1
 80004bc:	fa03 f101 	lsl.w	r1, r3, r1
 80004c0:	6181      	str	r1, [r0, #24]
 80004c2:	4770      	bx	lr

080004c4 <stm32_gpio_GPIO_ResetBit>:
}
void stm32_gpio_GPIO_ResetBit(stm32_gpio_GPIO* g, int n) {
	g->bsrr = 65536<<(uint)(n);
 80004c4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80004c8:	fa03 f101 	lsl.w	r1, r3, r1
 80004cc:	6181      	str	r1, [r0, #24]
 80004ce:	4770      	bx	lr

080004d0 <stm32_gpio_GPIO_SetBits>:
}
void stm32_gpio_GPIO_SetBits(stm32_gpio_GPIO* g, uint16 bits) {
	g->bsrr = (uint32)(bits);
 80004d0:	6181      	str	r1, [r0, #24]
 80004d2:	4770      	bx	lr

080004d4 <stm32_gpio_GPIO_ResetBits>:
}
void stm32_gpio_GPIO_ResetBits(stm32_gpio_GPIO* g, uint16 bits) {
	g->bsrr = (uint32)(bits)<<16;
 80004d4:	0409      	lsls	r1, r1, #16
 80004d6:	6181      	str	r1, [r0, #24]
 80004d8:	4770      	bx	lr

080004da <stm32_gpio_GPIO_SetBSRR>:
}
void stm32_gpio_GPIO_SetBSRR(stm32_gpio_GPIO* g, uint32 bsrr) {
	g->bsrr = bsrr;
 80004da:	6181      	str	r1, [r0, #24]
 80004dc:	4770      	bx	lr
	...

080004e0 <stm32_periph_AHB1ClockEnable>:

// Implementation

static stm32_periph_regs* stm32_periph_p = (stm32_periph_regs*)((unsafe_Pointer)(1073887248));
void stm32_periph_AHB1ClockEnable(stm32_periph_Dev d) {
	stm32_periph_p->ahb1enr |= (uint32)(d);
 80004e0:	4b02      	ldr	r3, [pc, #8]	; (80004ec <stm32_periph_AHB1ClockEnable+0xc>)
 80004e2:	6a1a      	ldr	r2, [r3, #32]
 80004e4:	4310      	orrs	r0, r2
 80004e6:	6218      	str	r0, [r3, #32]
 80004e8:	4770      	bx	lr
 80004ea:	bf00      	nop
 80004ec:	40023810 	.word	0x40023810

080004f0 <stm32_periph_AHB1ClockDisable>:
}
void stm32_periph_AHB1ClockDisable(stm32_periph_Dev d) {
	stm32_periph_p->ahb1enr &= ~((uint32)(d));
 80004f0:	4b02      	ldr	r3, [pc, #8]	; (80004fc <stm32_periph_AHB1ClockDisable+0xc>)
 80004f2:	6a1a      	ldr	r2, [r3, #32]
 80004f4:	ea22 0000 	bic.w	r0, r2, r0
 80004f8:	6218      	str	r0, [r3, #32]
 80004fa:	4770      	bx	lr
 80004fc:	40023810 	.word	0x40023810

08000500 <stm32_periph_AHB1Reset>:
}
void stm32_periph_AHB1Reset(stm32_periph_Dev d) {
	stm32_periph_p->ahb1rstr |= (uint32)(d);
 8000500:	4b04      	ldr	r3, [pc, #16]	; (8000514 <stm32_periph_AHB1Reset+0x14>)
 8000502:	681a      	ldr	r2, [r3, #0]
 8000504:	4302      	orrs	r2, r0
 8000506:	601a      	str	r2, [r3, #0]
	stm32_periph_p->ahb1rstr &= ~((uint32)(d));
 8000508:	681a      	ldr	r2, [r3, #0]
 800050a:	ea22 0000 	bic.w	r0, r2, r0
 800050e:	6018      	str	r0, [r3, #0]
 8000510:	4770      	bx	lr
 8000512:	bf00      	nop
 8000514:	40023810 	.word	0x40023810
